<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">

<title>class Nokogiri::XML::Node - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">
<link href="../../rdoc-tweaks.css" rel="stylesheet">


    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1260604-8"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-1260604-8');
    </script>
</head>
<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search" aria-autocomplete="list" aria-controls="search-results" type="text" name="search" placeholder="Search" spellcheck="false" title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results" aria-busy="false" aria-expanded="false" aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li>
<a href="#class-Nokogiri::XML::Node-label-Attributes">Attributes</a>
    </li>
<li>
<a href="#class-Nokogiri::XML::Node-label-Navigation">Navigation</a>
    </li>
<li>
<a href="#class-Nokogiri::XML::Node-label-Serialization">Serialization</a>
    </li>
<li>
<a href="#class-Nokogiri::XML::Node-label-Searching">Searching</a>
  </li>
</ul>
</div>


  <div id="class-metadata">
    
<div id="sections-section" class="nav-section">
  <h3>Sections</h3>

  <ul class="link-list" role="directory">
      <li><a href="#5Buntitled-5D"></a></li>
      <li><a href="#Manipulating+Document+Structure">Manipulating Document Structure</a></li>
      <li><a href="#Serialization+and+Generating+Output">Serialization and Generating Output</a></li>
      <li><a href="#Traversing+Document+Structure">Traversing Document Structure</a></li>
      <li><a href="#Working+With+Node+Attributes">Working With Node Attributes</a></li>
  </ul>
</div>

    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="../../Object.html">Object</a>
</p>
</div>

    
<div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
    <li>
<a class="include" href="PP/Node.html">Nokogiri::XML::PP::Node</a>
    </li>
<li>
<a class="include" href="Searchable.html">Nokogiri::XML::Searchable</a>
    </li>
<li>
<a class="include" href="../ClassResolver.html">Nokogiri::ClassResolver</a>
    </li>
<li>
<span class="include">Enumerable</span>
  </li>
</ul>
</div>

    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li>
<a href="#method-c-new">::new</a>
    </li>
<li>
<a href="#method-i-3C-3C">#&lt;&lt;</a>
    </li>
<li>
<a href="#method-i-3C-3D-3E">#&lt;=&gt;</a>
    </li>
<li>
<a href="#method-i-3D-3D">#==</a>
    </li>
<li>
<a href="#method-i-5B-5D">#[]</a>
    </li>
<li>
<a href="#method-i-5B-5D-3D">#[]=</a>
    </li>
<li>
<a href="#method-i-accept">#accept</a>
    </li>
<li>
<a href="#method-i-add_child">#add_child</a>
    </li>
<li>
<a href="#method-i-add_class">#add_class</a>
    </li>
<li>
<a href="#method-i-add_namespace">#add_namespace</a>
    </li>
<li>
<a href="#method-i-add_namespace_definition">#add_namespace_definition</a>
    </li>
<li>
<a href="#method-i-add_next_sibling">#add_next_sibling</a>
    </li>
<li>
<a href="#method-i-add_previous_sibling">#add_previous_sibling</a>
    </li>
<li>
<a href="#method-i-after">#after</a>
    </li>
<li>
<a href="#method-i-ancestors">#ancestors</a>
    </li>
<li>
<a href="#method-i-append_class">#append_class</a>
    </li>
<li>
<a href="#method-i-attr">#attr</a>
    </li>
<li>
<a href="#method-i-attribute">#attribute</a>
    </li>
<li>
<a href="#method-i-attribute_nodes">#attribute_nodes</a>
    </li>
<li>
<a href="#method-i-attribute_with_ns">#attribute_with_ns</a>
    </li>
<li>
<a href="#method-i-attributes">#attributes</a>
    </li>
<li>
<a href="#method-i-before">#before</a>
    </li>
<li>
<a href="#method-i-blank-3F">#blank?</a>
    </li>
<li>
<a href="#method-i-canonicalize">#canonicalize</a>
    </li>
<li>
<a href="#method-i-cdata-3F">#cdata?</a>
    </li>
<li>
<a href="#method-i-child">#child</a>
    </li>
<li>
<a href="#method-i-children">#children</a>
    </li>
<li>
<a href="#method-i-children-3D">#children=</a>
    </li>
<li>
<a href="#method-i-classes">#classes</a>
    </li>
<li>
<a href="#method-i-clone">#clone</a>
    </li>
<li>
<a href="#method-i-coerce">#coerce</a>
    </li>
<li>
<a href="#method-i-comment-3F">#comment?</a>
    </li>
<li>
<a href="#method-i-content">#content</a>
    </li>
<li>
<a href="#method-i-content-3D">#content=</a>
    </li>
<li>
<a href="#method-i-create_external_subset">#create_external_subset</a>
    </li>
<li>
<a href="#method-i-create_internal_subset">#create_internal_subset</a>
    </li>
<li>
<a href="#method-i-css_path">#css_path</a>
    </li>
<li>
<a href="#method-i-decorate-21">#decorate!</a>
    </li>
<li>
<a href="#method-i-default_namespace-3D">#default_namespace=</a>
    </li>
<li>
<a href="#method-i-delete">#delete</a>
    </li>
<li>
<a href="#method-i-description">#description</a>
    </li>
<li>
<a href="#method-i-do_xinclude">#do_xinclude</a>
    </li>
<li>
<a href="#method-i-document">#document</a>
    </li>
<li>
<a href="#method-i-document-3F">#document?</a>
    </li>
<li>
<a href="#method-i-dup">#dup</a>
    </li>
<li>
<a href="#method-i-each">#each</a>
    </li>
<li>
<a href="#method-i-elem-3F">#elem?</a>
    </li>
<li>
<a href="#method-i-element-3F">#element?</a>
    </li>
<li>
<a href="#method-i-element_children">#element_children</a>
    </li>
<li>
<a href="#method-i-elements">#elements</a>
    </li>
<li>
<a href="#method-i-encode_special_chars">#encode_special_chars</a>
    </li>
<li>
<a href="#method-i-external_subset">#external_subset</a>
    </li>
<li>
<a href="#method-i-first_element_child">#first_element_child</a>
    </li>
<li>
<a href="#method-i-fragment">#fragment</a>
    </li>
<li>
<a href="#method-i-fragment-3F">#fragment?</a>
    </li>
<li>
<a href="#method-i-get_attribute">#get_attribute</a>
    </li>
<li>
<a href="#method-i-has_attribute-3F">#has_attribute?</a>
    </li>
<li>
<a href="#method-i-html-3F">#html?</a>
    </li>
<li>
<a href="#method-i-inner_html">#inner_html</a>
    </li>
<li>
<a href="#method-i-inner_html-3D">#inner_html=</a>
    </li>
<li>
<a href="#method-i-inner_text">#inner_text</a>
    </li>
<li>
<a href="#method-i-internal_subset">#internal_subset</a>
    </li>
<li>
<a href="#method-i-key-3F">#key?</a>
    </li>
<li>
<a href="#method-i-keys">#keys</a>
    </li>
<li>
<a href="#method-i-kwattr_add">#kwattr_add</a>
    </li>
<li>
<a href="#method-i-kwattr_append">#kwattr_append</a>
    </li>
<li>
<a href="#method-i-kwattr_remove">#kwattr_remove</a>
    </li>
<li>
<a href="#method-i-kwattr_values">#kwattr_values</a>
    </li>
<li>
<a href="#method-i-lang">#lang</a>
    </li>
<li>
<a href="#method-i-lang-3D">#lang=</a>
    </li>
<li>
<a href="#method-i-last_element_child">#last_element_child</a>
    </li>
<li>
<a href="#method-i-line">#line</a>
    </li>
<li>
<a href="#method-i-line-3D">#line=</a>
    </li>
<li>
<a href="#method-i-matches-3F">#matches?</a>
    </li>
<li>
<a href="#method-i-name">#name</a>
    </li>
<li>
<a href="#method-i-name-3D">#name=</a>
    </li>
<li>
<a href="#method-i-namespace">#namespace</a>
    </li>
<li>
<a href="#method-i-namespace-3D">#namespace=</a>
    </li>
<li>
<a href="#method-i-namespace_definitions">#namespace_definitions</a>
    </li>
<li>
<a href="#method-i-namespace_scopes">#namespace_scopes</a>
    </li>
<li>
<a href="#method-i-namespaced_key-3F">#namespaced_key?</a>
    </li>
<li>
<a href="#method-i-namespaces">#namespaces</a>
    </li>
<li>
<a href="#method-i-native_content-3D">#native_content=</a>
    </li>
<li>
<a href="#method-i-next">#next</a>
    </li>
<li>
<a href="#method-i-next-3D">#next=</a>
    </li>
<li>
<a href="#method-i-next_element">#next_element</a>
    </li>
<li>
<a href="#method-i-next_sibling">#next_sibling</a>
    </li>
<li>
<a href="#method-i-node_name">#node_name</a>
    </li>
<li>
<a href="#method-i-node_name-3D">#node_name=</a>
    </li>
<li>
<a href="#method-i-node_type">#node_type</a>
    </li>
<li>
<a href="#method-i-parent">#parent</a>
    </li>
<li>
<a href="#method-i-parent-3D">#parent=</a>
    </li>
<li>
<a href="#method-i-parse">#parse</a>
    </li>
<li>
<a href="#method-i-path">#path</a>
    </li>
<li>
<a href="#method-i-pointer_id">#pointer_id</a>
    </li>
<li>
<a href="#method-i-prepend_child">#prepend_child</a>
    </li>
<li>
<a href="#method-i-previous">#previous</a>
    </li>
<li>
<a href="#method-i-previous-3D">#previous=</a>
    </li>
<li>
<a href="#method-i-previous_element">#previous_element</a>
    </li>
<li>
<a href="#method-i-previous_sibling">#previous_sibling</a>
    </li>
<li>
<a href="#method-i-processing_instruction-3F">#processing_instruction?</a>
    </li>
<li>
<a href="#method-i-read_only-3F">#read_only?</a>
    </li>
<li>
<a href="#method-i-remove">#remove</a>
    </li>
<li>
<a href="#method-i-remove_attribute">#remove_attribute</a>
    </li>
<li>
<a href="#method-i-remove_class">#remove_class</a>
    </li>
<li>
<a href="#method-i-replace">#replace</a>
    </li>
<li>
<a href="#method-i-serialize">#serialize</a>
    </li>
<li>
<a href="#method-i-set_attribute">#set_attribute</a>
    </li>
<li>
<a href="#method-i-swap">#swap</a>
    </li>
<li>
<a href="#method-i-text">#text</a>
    </li>
<li>
<a href="#method-i-text-3F">#text?</a>
    </li>
<li>
<a href="#method-i-to_html">#to_html</a>
    </li>
<li>
<a href="#method-i-to_s">#to_s</a>
    </li>
<li>
<a href="#method-i-to_str">#to_str</a>
    </li>
<li>
<a href="#method-i-to_xhtml">#to_xhtml</a>
    </li>
<li>
<a href="#method-i-to_xml">#to_xml</a>
    </li>
<li>
<a href="#method-i-traverse">#traverse</a>
    </li>
<li>
<a href="#method-i-type">#type</a>
    </li>
<li>
<a href="#method-i-unlink">#unlink</a>
    </li>
<li>
<a href="#method-i-value-3F">#value?</a>
    </li>
<li>
<a href="#method-i-values">#values</a>
    </li>
<li>
<a href="#method-i-wrap">#wrap</a>
    </li>
<li>
<a href="#method-i-write_html_to">#write_html_to</a>
    </li>
<li>
<a href="#method-i-write_to">#write_to</a>
    </li>
<li>
<a href="#method-i-write_xhtml_to">#write_xhtml_to</a>
    </li>
<li>
<a href="#method-i-write_xml_to">#write_xml_to</a>
    </li>
<li>
<a href="#method-i-xml-3F">#xml?</a>
  </li>
</ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Nokogiri::XML::Node">
  <h1 id="class-Nokogiri::XML::Node" class="class">
    class Nokogiri::XML::Node
  </h1>

  <section class="description">
    
<p><a href="Node.html"><code>Nokogiri::XML::Node</code></a> is the primary API you’ll use to interact with your <a href="Document.html"><code>Document</code></a>.</p>

<h2 id="class-Nokogiri::XML::Node-label-Attributes">Attributes<span><a href="#class-Nokogiri::XML::Node-label-Attributes">¶</a> <a href="#top">↑</a></span>
</h2>

<p>A <a href="Node.html"><code>Nokogiri::XML::Node</code></a> may be treated similarly to a hash with regard to attributes. For example:</p>

<pre class="ruby"><span class="ruby-identifier">node</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">DocumentFragment</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">"&lt;a href='#foo' id='link'&gt;link&lt;/a&gt;"</span>).<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"a"</span>)
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">to_html</span> <span class="ruby-comment"># =&gt; "&lt;a href=\"#foo\" id=\"link\"&gt;link&lt;/a&gt;"</span>
<span class="ruby-identifier">node</span>[<span class="ruby-string">'href'</span>] <span class="ruby-comment"># =&gt; "#foo"</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">keys</span> <span class="ruby-comment"># =&gt; ["href", "id"]</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">values</span> <span class="ruby-comment"># =&gt; ["#foo", "link"]</span>
<span class="ruby-identifier">node</span>[<span class="ruby-string">'class'</span>] = <span class="ruby-string">'green'</span> <span class="ruby-comment"># =&gt; "green"</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">to_html</span> <span class="ruby-comment"># =&gt; "&lt;a href=\"#foo\" id=\"link\" class=\"green\"&gt;link&lt;/a&gt;"</span>
</pre>

<p>See the method group entitled <a href="Node.html#class-Nokogiri::XML::Node-label-Working+With+Node+Attributes">Working With Node Attributes at <code>Node</code></a> for the full set of methods.</p>

<h2 id="class-Nokogiri::XML::Node-label-Navigation">Navigation<span><a href="#class-Nokogiri::XML::Node-label-Navigation">¶</a> <a href="#top">↑</a></span>
</h2>

<p><a href="Node.html"><code>Nokogiri::XML::Node</code></a> also has methods that let you move around your tree:</p>
<dl class="rdoc-list label-list">
<dt>
<a href="Node.html#method-i-parent"><code>#parent</code></a>, <a href="Node.html#method-i-children"><code>#children</code></a>, <a href="Node.html#method-i-next"><code>#next</code></a>, <a href="Node.html#method-i-previous"><code>#previous</code></a>
</dt>
<dd>
<p>Navigate up, down, or through siblings.</p>
</dd>
</dl>

<p>See the method group entitled <a href="Node.html#class-Nokogiri::XML::Node-label-Traversing+Document+Structure">Traversing Document Structure at <code>Node</code></a> for the full set of methods.</p>

<h2 id="class-Nokogiri::XML::Node-label-Serialization">Serialization<span><a href="#class-Nokogiri::XML::Node-label-Serialization">¶</a> <a href="#top">↑</a></span>
</h2>

<p>When printing or otherwise emitting a document or a node (and its subtree), there are a few methods you might want to use:</p>
<dl class="rdoc-list label-list">
<dt>
<a href="Node.html#method-i-content"><code>#content</code></a>, <a href="Node.html#method-i-text"><code>#text</code></a>, <a href="Node.html#method-i-inner_text"><code>#inner_text</code></a>, <a href="Node.html#method-i-to_str"><code>#to_str</code></a>
</dt>
<dd>
<p>These methods will all **emit plaintext**, meaning that entities will be replaced (e.g., +&amp;lt;+ will be replaced with +&lt;+), meaning that any sanitizing will likely be un-done in the output.</p>
</dd>
<dt>
<a href="Node.html#method-i-to_s"><code>#to_s</code></a>, <a href="Node.html#method-i-to_xml"><code>#to_xml</code></a>, <a href="Node.html#method-i-to_html"><code>#to_html</code></a>, <a href="Node.html#method-i-inner_html"><code>#inner_html</code></a>
</dt>
<dd>
<p>These methods will all **emit properly-escaped markup**, meaning that it’s suitable for consumption by browsers, parsers, etc.</p>
</dd>
</dl>

<p>See the method group entitled <a href="Node.html#class-Nokogiri::XML::Node-label-Serialization+and+Generating+Output">Serialization and Generating Output at <code>Node</code></a> for the full set of methods.</p>

<h2 id="class-Nokogiri::XML::Node-label-Searching">Searching<span><a href="#class-Nokogiri::XML::Node-label-Searching">¶</a> <a href="#top">↑</a></span>
</h2>

<p>You may search this node’s subtree using methods like <a href="Searchable.html#method-i-xpath"><code>#xpath</code></a> and <a href="Searchable.html#method-i-css"><code>#css</code></a>.</p>

<p>See the method group entitled <a href="Node.html#class-Nokogiri::XML::Node-label-Searching+via+XPath+or+CSS+Queries">Searching via XPath or CSS Queries at <code>Node</code></a> for the full set of methods.</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">


    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
        <dt id="ATTRIBUTE_DECL">ATTRIBUTE_DECL
        </dt>
<dd>
<p>Attribute declaration type</p>
        </dd>
<dt id="ATTRIBUTE_NODE">ATTRIBUTE_NODE
        </dt>
<dd>
<p>Attribute node type</p>
        </dd>
<dt id="CDATA_SECTION_NODE">CDATA_SECTION_NODE
        </dt>
<dd>
<p><a href="CDATA.html"><code>CDATA</code></a> node type, see <a href="Node.html#method-i-cdata-3F"><code>Nokogiri::XML::Node#cdata?</code></a></p>
        </dd>
<dt id="COMMENT_NODE">COMMENT_NODE
        </dt>
<dd>
<p><a href="Comment.html"><code>Comment</code></a> node type, see <a href="Node.html#method-i-comment-3F"><code>Nokogiri::XML::Node#comment?</code></a></p>
        </dd>
<dt id="DOCB_DOCUMENT_NODE">DOCB_DOCUMENT_NODE
        </dt>
<dd>
<p>DOCB document node type</p>
        </dd>
<dt id="DOCUMENT_FRAG_NODE">DOCUMENT_FRAG_NODE
        </dt>
<dd>
<p><a href="Document.html"><code>Document</code></a> fragment node type</p>
        </dd>
<dt id="DOCUMENT_NODE">DOCUMENT_NODE
        </dt>
<dd>
<p><a href="Document.html"><code>Document</code></a> node type, see <a href="Node.html#method-i-xml-3F"><code>Nokogiri::XML::Node#xml?</code></a></p>
        </dd>
<dt id="DOCUMENT_TYPE_NODE">DOCUMENT_TYPE_NODE
        </dt>
<dd>
<p><a href="Document.html"><code>Document</code></a> type node type</p>
        </dd>
<dt id="DTD_NODE">DTD_NODE
        </dt>
<dd>
<p><a href="DTD.html"><code>DTD</code></a> node type</p>
        </dd>
<dt id="ELEMENT_DECL">ELEMENT_DECL
        </dt>
<dd>
<p><a href="Element.html"><code>Element</code></a> declaration type</p>
        </dd>
<dt id="ELEMENT_NODE">ELEMENT_NODE
        </dt>
<dd>
<p><a href="Element.html"><code>Element</code></a> node type, see <a href="Node.html#method-i-element-3F"><code>Nokogiri::XML::Node#element?</code></a></p>
        </dd>
<dt id="ENTITY_DECL">ENTITY_DECL
        </dt>
<dd>
<p>Entity declaration type</p>
        </dd>
<dt id="ENTITY_NODE">ENTITY_NODE
        </dt>
<dd>
<p>Entity node type</p>
        </dd>
<dt id="ENTITY_REF_NODE">ENTITY_REF_NODE
        </dt>
<dd>
<p>Entity reference node type</p>
        </dd>
<dt id="HTML_DOCUMENT_NODE">HTML_DOCUMENT_NODE
        </dt>
<dd>
<p><a href="../HTML4.html"><code>HTML</code></a> document node type, see <a href="Node.html#method-i-html-3F"><code>Nokogiri::XML::Node#html?</code></a></p>
        </dd>
<dt id="IMPLIED_XPATH_CONTEXTS">IMPLIED_XPATH_CONTEXTS
        </dt>
<dd>
        </dd>
<dt id="NAMESPACE_DECL">NAMESPACE_DECL
        </dt>
<dd>
<p><a href="Namespace.html"><code>Namespace</code></a> declaration type</p>
        </dd>
<dt id="NOTATION_NODE">NOTATION_NODE
        </dt>
<dd>
<p><a href="Notation.html"><code>Notation</code></a> node type</p>
        </dd>
<dt id="PI_NODE">PI_NODE
        </dt>
<dd>
<p>PI node type</p>
        </dd>
<dt id="TEXT_NODE">TEXT_NODE
        </dt>
<dd>
<p><a href="Text.html"><code>Text</code></a> node type, see <a href="Node.html#method-i-text-3F"><code>Nokogiri::XML::Node#text?</code></a></p>
        </dd>
<dt id="XINCLUDE_END">XINCLUDE_END
        </dt>
<dd>
<p>XInclude end type</p>
        </dd>
<dt id="XINCLUDE_START">XINCLUDE_START
        </dt>
<dd>
<p>XInclude start type</p>
      </dd>
</dl>
    </section>



     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-new" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            new(name, document) → Nokogiri::XML::Node
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(name, document) { |node| ... } → Nokogiri::XML::Node
          </span>
        </div>

        <div class="method-description">
          <p>Create a new node with <code>name</code> that belongs to <code>document</code>.</p>

<p>If you intend to add a node to a document tree, it’s likely that you will prefer one of the <a href="Node.html"><code>Nokogiri::XML::Node</code></a> methods like <a href="Node.html#method-i-add_child"><code>#add_child</code></a>, <a href="Node.html#method-i-add_next_sibling"><code>#add_next_sibling</code></a>, <a href="Node.html#method-i-replace"><code>#replace</code></a>, etc. which will both create an element (or subtree) and place it in the document tree.</p>

<p>Another alternative, if you are concerned about performance, is <a href="Document.html#method-i-create_element"><code>Nokogiri::XML::Document#create_element</code></a> which accepts additional arguments for contents or attributes but (like this method) avoids parsing markup.</p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul>
<li>
<p><code>name</code> (String)</p>
</li>
<li>
<p><code>document</code> (<a href="Document.html"><code>Nokogiri::XML::Document</code></a>) The document to which the the returned node will belong.</p>
</li>
</ul>
<dl class="rdoc-list label-list">
<dt>Yields
</dt>
<dd>
<p><a href="Node.html"><code>Nokogiri::XML::Node</code></a></p>
</dd>
<dt>Returns
</dt>
<dd>
<p><a href="Node.html"><code>Nokogiri::XML::Node</code></a></p>
</dd>
</dl>

          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 126</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">document</span>)
  <span class="ruby-comment"># This is intentionally empty.</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-3C-3D-3E" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">&lt;=&gt;</span><span class="method-args">(other)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Compare two <a href="Node.html"><code>Node</code></a> objects with respect to their <a href="Document.html"><code>Document</code></a>.  Nodes from different documents cannot be compared.</p>

          <div class="method-source-code" id="3C-3D-3E-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;=&gt;</span>(<span class="ruby-identifier">other</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">other</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">document</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">other</span>.<span class="ruby-identifier">document</span>
  <span class="ruby-identifier">compare</span>(<span class="ruby-identifier">other</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-3D-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">==</span><span class="method-args">(other)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Test to see if this <a href="Node.html"><code>Node</code></a> is equal to <code>other</code></p>

          <div class="method-source-code" id="3D-3D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1150</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">other</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">other</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:pointer_id</span>)
  <span class="ruby-identifier">pointer_id</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">other</span>.<span class="ruby-identifier">pointer_id</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-accept" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">accept</span><span class="method-args">(visitor)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Accept a visitor.  This method calls “visit” on <code>visitor</code> with self.</p>

          <div class="method-source-code" id="accept-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">accept</span>(<span class="ruby-identifier">visitor</span>)
  <span class="ruby-identifier">visitor</span>.<span class="ruby-identifier">visit</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-ancestors" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">ancestors</span><span class="method-args">(selector = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get a list of ancestor <a href="Node.html"><code>Node</code></a> for this <a href="Node.html"><code>Node</code></a>.  If <code>selector</code> is given, the ancestors must match <code>selector</code></p>

          <div class="method-source-code" id="ancestors-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1114</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ancestors</span>(<span class="ruby-identifier">selector</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">NodeSet</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">document</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:parent</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-constant">NodeSet</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">document</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parent</span>

  <span class="ruby-identifier">parents</span> = [<span class="ruby-identifier">parent</span>]

  <span class="ruby-keyword">while</span> <span class="ruby-identifier">parents</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:parent</span>)
    <span class="ruby-keyword">break</span> <span class="ruby-keyword">unless</span> (<span class="ruby-identifier">ctx_parent</span> = <span class="ruby-identifier">parents</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">parent</span>)
    <span class="ruby-identifier">parents</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">ctx_parent</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-constant">NodeSet</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">document</span>, <span class="ruby-identifier">parents</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">selector</span>

  <span class="ruby-identifier">root</span> = <span class="ruby-identifier">parents</span>.<span class="ruby-identifier">last</span>
  <span class="ruby-identifier">search_results</span> = <span class="ruby-identifier">root</span>.<span class="ruby-identifier">search</span>(<span class="ruby-identifier">selector</span>)

  <span class="ruby-constant">NodeSet</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">document</span>, <span class="ruby-identifier">parents</span>.<span class="ruby-identifier">find_all</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">parent</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">search_results</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">parent</span>)
  <span class="ruby-keyword">end</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-blank-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            blank? → Boolean
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><code>true</code> if the node is an empty or whitespace-only text or cdata node, else <code>false</code>.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<pre class="ruby"><span class="ruby-constant">Nokogiri</span>(<span class="ruby-string">"&lt;root&gt;&lt;child/&gt;&lt;/root&gt;"</span>).<span class="ruby-identifier">root</span>.<span class="ruby-identifier">child</span>.<span class="ruby-identifier">blank?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-constant">Nokogiri</span>(<span class="ruby-string">"&lt;root&gt;\t \n&lt;/root&gt;"</span>).<span class="ruby-identifier">root</span>.<span class="ruby-identifier">child</span>.<span class="ruby-identifier">blank?</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Nokogiri</span>(<span class="ruby-string">"&lt;root&gt;&lt;![CDATA[\t \n]]&gt;&lt;/root&gt;"</span>).<span class="ruby-identifier">root</span>.<span class="ruby-identifier">child</span>.<span class="ruby-identifier">blank?</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Nokogiri</span>(<span class="ruby-string">"&lt;root&gt;not-blank&lt;/root&gt;"</span>).<span class="ruby-identifier">root</span>.<span class="ruby-identifier">child</span>
  .<span class="ruby-identifier">tap</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">content</span> = <span class="ruby-string">""</span> }.<span class="ruby-identifier">blank</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="blank-3F-source">
            <pre>static VALUE
rb_xml_node_blank_eh(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return (1 == xmlIsBlankNode(node)) ? Qtrue : Qfalse ;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-cdata-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">cdata?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is a <a href="CDATA.html"><code>CDATA</code></a></p>

          <div class="method-source-code" id="cdata-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1036</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cdata?</span>
  <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">CDATA_SECTION_NODE</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-clone" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">clone</span><span class="method-args">(p1 = v1, p2 = v2)</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-dup">dup</a>
        </div>
      </div>

      <div id="method-i-comment-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">comment?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is a <a href="Comment.html"><code>Comment</code></a></p>

          <div class="method-source-code" id="comment-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1031</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">comment?</span>
  <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">COMMENT_NODE</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-content" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            content() → String
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Contents of all the text nodes in this node’s subtree, concatenated together into a single String.</p>
</dd>
</dl>

<p>⚠ Note that entities will <em>always</em> be expanded in the returned String.</p>

<p>See related: <a href="Node.html#method-i-inner_html"><code>#inner_html</code></a></p>

<p><strong>Example</strong> of how entities are handled:</p>

<p>Note that <code>&amp;lt;</code> becomes <code>&lt;</code> in the returned String.</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>.<span class="ruby-identifier">fragment</span>(<span class="ruby-string">"&lt;child&gt;a &amp;lt; b&lt;/child&gt;"</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">content</span>
<span class="ruby-comment"># =&gt; "a &lt; b"</span>
</pre>

<p><strong>Example</strong> of how a subtree is handled:</p>

<p>Note that the <code>&lt;span&gt;</code> tags are omitted and only the text node contents are returned, concatenated into a single string.</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>.<span class="ruby-identifier">fragment</span>(<span class="ruby-string">"&lt;child&gt;&lt;span&gt;first&lt;/span&gt; &lt;span&gt;second&lt;/span&gt;&lt;/child&gt;"</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">content</span>
<span class="ruby-comment"># =&gt; "first second"</span>
</pre>

          <div class="method-source-code" id="content-source">
            <pre>static VALUE
rb_xml_node_content(VALUE self)
{
  xmlNodePtr node;
  xmlChar *content;

  Data_Get_Struct(self, xmlNode, node);

  content = xmlNodeGetContent(node);
  if (content) {
    VALUE rval = NOKOGIRI_STR_NEW2(content);
    xmlFree(content);
    return rval;
  }
  return Qnil;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-inner_text">inner_text</a>, <a href="Node.html#method-i-text">text</a>, <a href="Node.html#method-i-to_str">to_str</a>
        </div>

      </div>

      <div id="method-i-create_external_subset" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            create_external_subset(name, external_id, system_id)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Create an external subset</p>

          <div class="method-source-code" id="create_external_subset-source">
            <pre>static VALUE
create_external_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if (doc-&gt;extSubset) {
    rb_raise(rb_eRuntimeError, "Document already has an external subset");
  }

  dtd = xmlNewDtd(
          doc,
          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
        );

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-create_internal_subset" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            create_internal_subset(name, external_id, system_id)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Create the internal subset of a document.</p>

<pre class="ruby"><span class="ruby-identifier">doc</span>.<span class="ruby-identifier">create_internal_subset</span>(<span class="ruby-string">"chapter"</span>, <span class="ruby-string">"-//OASIS//DTD DocBook XML//EN"</span>, <span class="ruby-string">"chapter.dtd"</span>)
<span class="ruby-comment"># =&gt; &lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "chapter.dtd"&gt;</span>

<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">create_internal_subset</span>(<span class="ruby-string">"chapter"</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-string">"chapter.dtd"</span>)
<span class="ruby-comment"># =&gt; &lt;!DOCTYPE chapter SYSTEM "chapter.dtd"&gt;</span>
</pre>

          <div class="method-source-code" id="create_internal_subset-source">
            <pre>static VALUE
create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if (xmlGetIntSubset(doc)) {
    rb_raise(rb_eRuntimeError, "Document already has an internal subset");
  }

  dtd = xmlCreateIntSubset(
          doc,
          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
        );

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-css_path" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">css_path</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get the path to this node as a <a href="../CSS.html"><code>CSS</code></a> expression</p>

          <div class="method-source-code" id="css_path-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1105</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">css_path</span>
  <span class="ruby-identifier">path</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">%r{/}</span>).<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">part</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">part</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">part</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/\[(\d+)\]/</span>, <span class="ruby-string">':nth-of-type(\1)'</span>)
  <span class="ruby-keyword">end</span>.<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">" &gt; "</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-decorate-21" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">decorate!</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Decorate this node with the decorators set up in this node’s <a href="Document.html"><code>Document</code></a></p>

          <div class="method-source-code" id="decorate-21-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">decorate!</span>
  <span class="ruby-identifier">document</span>.<span class="ruby-identifier">decorate</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-description" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">description</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Fetch the <a href="../HTML4/ElementDescription.html"><code>Nokogiri::HTML4::ElementDescription</code></a> for this node.  Returns nil on <a href="../XML.html"><code>XML</code></a> documents and on unknown tags.</p>

          <div class="method-source-code" id="description-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1073</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">description</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">xml?</span>
  <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">HTML4</span><span class="ruby-operator">::</span><span class="ruby-constant">ElementDescription</span>[<span class="ruby-identifier">name</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-document-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">document?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is a <a href="Document.html"><code>Document</code></a></p>

          <div class="method-source-code" id="document-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1051</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">document?</span>
  <span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-dup" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            dup → Nokogiri::XML::Node
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            dup(depth) → Nokogiri::XML::Node
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            dup(depth, new_parent_doc) → Nokogiri::XML::Node
          </span>
        </div>

        <div class="method-description">
          <p>Copy this node.</p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul>
<li>
<p><code>depth</code> 0 is a shallow copy, 1 (the default) is a deep copy.</p>
</li>
<li>
<p><code>new_parent_doc</code> The new node’s parent <a href="Document.html"><code>Document</code></a>. Defaults to the this node’s document.</p>
</li>
</ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>The new Nokgiri::XML::Node</p>
</dd>
</dl>

          <div class="method-source-code" id="dup-source">
            <pre>static VALUE
duplicate_node(int argc, VALUE *argv, VALUE self)
{
  VALUE r_level, r_new_parent_doc;
  int level;
  int n_args;
  xmlDocPtr new_parent_doc;
  xmlNodePtr node, dup;

  Data_Get_Struct(self, xmlNode, node);

  n_args = rb_scan_args(argc, argv, "02", &amp;r_level, &amp;r_new_parent_doc);

  if (n_args &lt; 1) {
    r_level = INT2NUM((long)1);
  }
  level = (int)NUM2INT(r_level);

  if (n_args &lt; 2) {
    new_parent_doc = node-&gt;doc;
  } else {
    Data_Get_Struct(r_new_parent_doc, xmlDoc, new_parent_doc);
  }

  dup = xmlDocCopyNode(node, new_parent_doc, level);
  if (dup == NULL) { return Qnil; }

  noko_xml_document_pin_node(dup);

  return noko_xml_node_wrap(rb_obj_class(self), dup);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-clone">clone</a>
        </div>

      </div>

      <div id="method-i-elem-3F" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">elem?</span><span class="method-args">()</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-element-3F">element?</a>
        </div>
      </div>

      <div id="method-i-element-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">element?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is an <a href="Element.html"><code>Element</code></a> node</p>

          <div class="method-source-code" id="element-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1086</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">element?</span>
  <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">ELEMENT_NODE</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-elem-3F">elem?</a>
        </div>

      </div>

      <div id="method-i-element_children" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            element_children() → NodeSet
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>The node’s child elements as a <a href="NodeSet.html"><code>NodeSet</code></a>. Only children that are elements will be returned, which notably excludes <a href="Text.html"><code>Text</code></a> nodes.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<p>Note that <a href="Node.html#method-i-children"><code>#children</code></a> returns the <a href="Text.html"><code>Text</code></a> node “hello” while <a href="Node.html#method-i-element_children"><code>#element_children</code></a> does not.</p>

<pre class="ruby"><span class="ruby-identifier">div</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">HTML5</span>(<span class="ruby-string">"&lt;div&gt;hello&lt;span&gt;world&lt;/span&gt;"</span>).<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"div"</span>)
<span class="ruby-identifier">div</span>.<span class="ruby-identifier">element_children</span>
<span class="ruby-comment"># =&gt; [#&lt;Nokogiri::XML::Element:0x50 name="span" children=[#&lt;Nokogiri::XML::Text:0x3c "world"&gt;]&gt;]</span>
<span class="ruby-identifier">div</span>.<span class="ruby-identifier">children</span>
<span class="ruby-comment"># =&gt; [#&lt;Nokogiri::XML::Text:0x64 "hello"&gt;,</span>
<span class="ruby-comment">#     #&lt;Nokogiri::XML::Element:0x50 name="span" children=[#&lt;Nokogiri::XML::Text:0x3c "world"&gt;]&gt;]</span>
</pre>

          <div class="method-source-code" id="element_children-source">
            <pre>static VALUE
rb_xml_node_element_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if (!child) { return noko_xml_node_set_wrap(set, document); }

  child = xmlNextElementSibling(child);
  while (NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = xmlNextElementSibling(child);
  }

  node_set = noko_xml_node_set_wrap(set, document);

  return node_set;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-elements">elements</a>
        </div>

      </div>

      <div id="method-i-elements" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            elements() → NodeSet
          </span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-element_children">element_children</a>
        </div>
      </div>

      <div id="method-i-encode_special_chars" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            encode_special_chars(string) → String
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Encode any special characters in <code>string</code></p>

          <div class="method-source-code" id="encode_special_chars-source">
            <pre>static VALUE
encode_special_chars(VALUE self, VALUE string)
{
  xmlNodePtr node;
  xmlChar *encoded;
  VALUE encoded_str;

  Data_Get_Struct(self, xmlNode, node);
  encoded = xmlEncodeSpecialChars(
              node-&gt;doc,
              (const xmlChar *)StringValueCStr(string)
            );

  encoded_str = NOKOGIRI_STR_NEW2(encoded);
  xmlFree(encoded);

  return encoded_str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-external_subset" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            external_subset()
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get the external subset</p>

          <div class="method-source-code" id="external_subset-source">
            <pre>static VALUE
external_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if (!node-&gt;doc) { return Qnil; }

  doc = node-&gt;doc;
  dtd = doc-&gt;extSubset;

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-first_element_child" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            first_element_child() → Node
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>The first child <a href="Node.html"><code>Node</code></a> that is an element.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<p>Note that the “hello” child, which is a <a href="Text.html"><code>Text</code></a> node, is skipped and the <code>&lt;span&gt;</code> element is returned.</p>

<pre class="ruby"><span class="ruby-identifier">div</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">HTML5</span>(<span class="ruby-string">"&lt;div&gt;hello&lt;span&gt;world&lt;/span&gt;"</span>).<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"div"</span>)
<span class="ruby-identifier">div</span>.<span class="ruby-identifier">first_element_child</span>
<span class="ruby-comment"># =&gt; #(Element:0x3c { name = "span", children = [ #(Text "world")] })</span>
</pre>

          <div class="method-source-code" id="first_element_child-source">
            <pre>static VALUE
rb_xml_node_first_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-fragment" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">fragment</span><span class="method-args">(tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Create a <a href="DocumentFragment.html"><code>DocumentFragment</code></a> containing <code>tags</code> that is relative to <em>this</em> context node.</p>

          <div class="method-source-code" id="fragment-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 928</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fragment</span>(<span class="ruby-identifier">tags</span>)
  <span class="ruby-identifier">document</span>.<span class="ruby-identifier">related_class</span>(<span class="ruby-string">"DocumentFragment"</span>).<span class="ruby-identifier">new</span>(<span class="ruby-identifier">document</span>, <span class="ruby-identifier">tags</span>, <span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-fragment-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">fragment?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is a <a href="DocumentFragment.html"><code>DocumentFragment</code></a></p>

          <div class="method-source-code" id="fragment-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1066</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">fragment?</span>
  <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">DOCUMENT_FRAG_NODE</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-html-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">html?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is an <a href="../HTML4/Document.html"><code>HTML4::Document</code></a> or <a href="../HTML5/Document.html"><code>HTML5::Document</code></a> node</p>

          <div class="method-source-code" id="html-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1046</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">html?</span>
  <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">HTML_DOCUMENT_NODE</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-inner_html" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">inner_html</span><span class="method-args">(*args)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get the <a href="Node.html#method-i-inner_html"><code>inner_html</code></a> for this node’s <a href="Node.html#method-i-children"><code>Node#children</code></a></p>

          <div class="method-source-code" id="inner_html-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inner_html</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">children</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_html</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>) }.<span class="ruby-identifier">join</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-inner_text" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">inner_text</span><span class="method-args">()</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-content">content</a>
        </div>
      </div>

      <div id="method-i-internal_subset" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            internal_subset()
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get the internal subset</p>

          <div class="method-source-code" id="internal_subset-source">
            <pre>static VALUE
internal_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if (!node-&gt;doc) { return Qnil; }

  doc = node-&gt;doc;
  dtd = xmlGetIntSubset(doc);

  if (!dtd) { return Qnil; }

  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-key-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            key?(attribute)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if <code>attribute</code> is set</p>

          <div class="method-source-code" id="key-3F-source">
            <pre>static VALUE
key_eh(VALUE self, VALUE attribute)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if (xmlHasProp(node, (xmlChar *)StringValueCStr(attribute))) {
    return Qtrue;
  }
  return Qfalse;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-has_attribute-3F">has_attribute?</a>
        </div>

      </div>

      <div id="method-i-lang" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            lang
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</p>

          <div class="method-source-code" id="lang-source">
            <pre>static VALUE
get_lang(VALUE self_rb)
{
  xmlNodePtr self ;
  xmlChar *lang ;
  VALUE lang_rb ;

  Data_Get_Struct(self_rb, xmlNode, self);

  lang = xmlNodeGetLang(self);
  if (lang) {
    lang_rb = NOKOGIRI_STR_NEW2(lang);
    xmlFree(lang);
    return lang_rb ;
  }

  return Qnil ;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-lang-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            lang=
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the language of a node, i.e. the values of the xml:lang attribute.</p>

          <div class="method-source-code" id="lang-3D-source">
            <pre>static VALUE
set_lang(VALUE self_rb, VALUE lang_rb)
{
  xmlNodePtr self ;
  xmlChar *lang ;

  Data_Get_Struct(self_rb, xmlNode, self);
  lang = (xmlChar *)StringValueCStr(lang_rb);

  xmlNodeSetLang(self, lang);

  return Qnil ;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-last_element_child" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            last_element_child() → Node
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>The last child <a href="Node.html"><code>Node</code></a> that is an element.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<p>Note that the “hello” child, which is a <a href="Text.html"><code>Text</code></a> node, is skipped and the <code>&lt;span&gt;yes&lt;/span&gt;</code> element is returned.</p>

<pre class="ruby"><span class="ruby-identifier">div</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">HTML5</span>(<span class="ruby-string">"&lt;div&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;skip&lt;/div&gt;"</span>).<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"div"</span>)
<span class="ruby-identifier">div</span>.<span class="ruby-identifier">last_element_child</span>
<span class="ruby-comment"># =&gt; #(Element:0x3c { name = "span", children = [ #(Text "yes")] })</span>
</pre>

          <div class="method-source-code" id="last_element_child-source">
            <pre>static VALUE
rb_xml_node_last_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlLastElementChild(node);
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-line" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            line() → Integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>The line number of this <a href="Node.html"><code>Node</code></a>.</p>
</dd>
</dl>
<hr>

<p><strong> ⚠ The CRuby and JRuby implementations differ in important ways! </strong></p>

<p>Semantic differences:</p>
<ul>
<li>
<p>The CRuby method reflects the node’s line number <em>in the parsed string</em></p>
</li>
<li>
<p>The JRuby method reflects the node’s line number <em>in the final DOM structure</em> after corrections have been applied</p>
</li>
</ul>

<p>Performance differences:</p>
<ul>
<li>
<p>The CRuby method is <a href="https://en.wikipedia.org/wiki/Time_complexity#Constant_time">O(1)</a> (constant time)</p>
</li>
<li>
<p>The JRuby method is <a href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time">O(n)</a> (linear time, where n is the number of nodes before/above the element in the DOM)</p>
</li>
</ul>

<p>If you’d like to help improve the JRuby implementation, please review these issues and reach out to the maintainers:</p>
<ul>
<li>
<p><a href="https://github.com/sparklemotion/nokogiri/issues/1223">github.com/sparklemotion/nokogiri/issues/1223</a></p>
</li>
<li>
<p><a href="https://github.com/sparklemotion/nokogiri/pull/2177">github.com/sparklemotion/nokogiri/pull/2177</a></p>
</li>
<li>
<p><a href="https://github.com/sparklemotion/nokogiri/issues/2380">github.com/sparklemotion/nokogiri/issues/2380</a></p>
</li>
</ul>

          <div class="method-source-code" id="line-source">
            <pre>static VALUE
rb_xml_node_line(VALUE rb_node)
{
  xmlNodePtr c_node;
  Data_Get_Struct(rb_node, xmlNode, c_node);

  return INT2NUM(xmlGetLineNo(c_node));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-line-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            line=(num)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Sets the line for this <a href="Node.html"><code>Node</code></a>. num must be less than 65535.</p>

          <div class="method-source-code" id="line-3D-source">
            <pre>static VALUE
rb_xml_node_line_set(VALUE rb_node, VALUE rb_line_number)
{
  xmlNodePtr c_node;
  int line_number = NUM2INT(rb_line_number);

  Data_Get_Struct(rb_node, xmlNode, c_node);

  // libxml2 optionally uses xmlNode.psvi to store longer line numbers, but only for text nodes.
  // search for "psvi" in SAX2.c and tree.c to learn more.
  if (line_number &lt; 65535) {
    c_node-&gt;line = (short) line_number;
  } else {
    c_node-&gt;line = 65535;
    if (c_node-&gt;type == XML_TEXT_NODE) {
      c_node-&gt;psvi = (void *)(ptrdiff_t) line_number;
    }
  }

  return rb_line_number;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-matches-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">matches?</span><span class="method-args">(selector)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this <a href="Node.html"><code>Node</code></a> matches <code>selector</code></p>

          <div class="method-source-code" id="matches-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 921</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">matches?</span>(<span class="ruby-identifier">selector</span>)
  <span class="ruby-identifier">ancestors</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">search</span>(<span class="ruby-identifier">selector</span>).<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-name" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            name
          </span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-node_name">node_name</a>
        </div>
      </div>

      <div id="method-i-namespace" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            namespace() → Namespace
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>The <a href="Namespace.html"><code>Namespace</code></a> of the element or attribute node, or <code>nil</code> if there is no namespace.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;foo:third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//first"</span>).<span class="ruby-identifier">namespace</span>
<span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//xmlns:second"</span>, <span class="ruby-string">"xmlns"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/child"</span>).<span class="ruby-identifier">namespace</span>
<span class="ruby-comment"># =&gt; #(Namespace:0x3c { href = "http://example.com/child" })</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//foo:third"</span>, <span class="ruby-string">"foo"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/foo"</span>).<span class="ruby-identifier">namespace</span>
<span class="ruby-comment"># =&gt; #(Namespace:0x50 { prefix = "foo", href = "http://example.com/foo" })</span>
</pre>

          <div class="method-source-code" id="namespace-source">
            <pre>static VALUE
rb_xml_node_namespace(VALUE rb_node)
{
  xmlNodePtr c_node ;
  Data_Get_Struct(rb_node, xmlNode, c_node);

  if (c_node-&gt;ns) {
    return noko_xml_namespace_wrap(c_node-&gt;ns, c_node-&gt;doc);
  }

  return Qnil ;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-namespace_definitions" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            namespace_definitions() → Array&lt;Nokogiri::XML::Namespace&gt;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Namespaces that are defined directly on this node, as an Array of <a href="Namespace.html"><code>Namespace</code></a> objects. The array will be empty if no namespaces are defined on this node.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns="http://example.com/root"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child" xmlns:unused="http://example.com/unused"/&gt;
    &lt;foo:third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//root:first"</span>, <span class="ruby-string">"root"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/root"</span>).<span class="ruby-identifier">namespace_definitions</span>
<span class="ruby-comment"># =&gt; []</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//xmlns:second"</span>, <span class="ruby-string">"xmlns"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/child"</span>).<span class="ruby-identifier">namespace_definitions</span>
<span class="ruby-comment"># =&gt; [#(Namespace:0x3c { href = "http://example.com/child" }),</span>
<span class="ruby-comment">#     #(Namespace:0x50 {</span>
<span class="ruby-comment">#       prefix = "unused",</span>
<span class="ruby-comment">#       href = "http://example.com/unused"</span>
<span class="ruby-comment">#       })]</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//foo:third"</span>, <span class="ruby-string">"foo"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/foo"</span>).<span class="ruby-identifier">namespace_definitions</span>
<span class="ruby-comment"># =&gt; [#(Namespace:0x64 { prefix = "foo", href = "http://example.com/foo" })]</span>
</pre>

          <div class="method-source-code" id="namespace_definitions-source">
            <pre>static VALUE
namespace_definitions(VALUE rb_node)
{
  /* this code in the mode of xmlHasProp() */
  xmlNodePtr c_node ;
  xmlNsPtr c_namespace;
  VALUE definitions = rb_ary_new();

  Data_Get_Struct(rb_node, xmlNode, c_node);

  c_namespace = c_node-&gt;nsDef;
  if (!c_namespace) {
    return definitions;
  }

  while (c_namespace != NULL) {
    rb_ary_push(definitions, noko_xml_namespace_wrap(c_namespace, c_node-&gt;doc));
    c_namespace = c_namespace-&gt;next;
  }

  return definitions;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-namespace_scopes" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            namespace_scopes() → Array&lt;Nokogiri::XML::Namespace&gt;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Array of all the Namespaces on this node and its ancestors.</p>
</dd>
</dl>

<p>See also <a href="Node.html#method-i-namespaces"><code>#namespaces</code></a></p>

<p><strong>Example:</strong></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns="http://example.com/root" xmlns:bar="http://example.com/bar"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//root:first"</span>, <span class="ruby-string">"root"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/root"</span>).<span class="ruby-identifier">namespace_scopes</span>
<span class="ruby-comment"># =&gt; [#(Namespace:0x3c { href = "http://example.com/root" }),</span>
<span class="ruby-comment">#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//child:second"</span>, <span class="ruby-string">"child"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/child"</span>).<span class="ruby-identifier">namespace_scopes</span>
<span class="ruby-comment"># =&gt; [#(Namespace:0x64 { href = "http://example.com/child" }),</span>
<span class="ruby-comment">#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//root:third"</span>, <span class="ruby-string">"root"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/root"</span>).<span class="ruby-identifier">namespace_scopes</span>
<span class="ruby-comment"># =&gt; [#(Namespace:0x78 { prefix = "foo", href = "http://example.com/foo" }),</span>
<span class="ruby-comment">#     #(Namespace:0x3c { href = "http://example.com/root" }),</span>
<span class="ruby-comment">#     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]</span>
</pre>

          <div class="method-source-code" id="namespace_scopes-source">
            <pre>static VALUE
rb_xml_node_namespace_scopes(VALUE rb_node)
{
  xmlNodePtr c_node ;
  xmlNsPtr *namespaces;
  VALUE scopes = rb_ary_new();
  int j;

  Data_Get_Struct(rb_node, xmlNode, c_node);

  namespaces = xmlGetNsList(c_node-&gt;doc, c_node);
  if (!namespaces) {
    return scopes;
  }

  for (j = 0 ; namespaces[j] != NULL ; ++j) {
    rb_ary_push(scopes, noko_xml_namespace_wrap(namespaces[j], c_node-&gt;doc));
  }

  xmlFree(namespaces);
  return scopes;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-namespaced_key-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            namespaced_key?(attribute, namespace)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if <code>attribute</code> is set with <code>namespace</code></p>

          <div class="method-source-code" id="namespaced_key-3F-source">
            <pre>static VALUE
namespaced_key_eh(VALUE self, VALUE attribute, VALUE namespace)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if (xmlHasNsProp(node, (xmlChar *)StringValueCStr(attribute),
                   NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace))) {
    return Qtrue;
  }
  return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-namespaces" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            namespaces() → Hash&lt;String(Namespace#prefix) ⇒ String(Namespace#href)&gt;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Fetch all the namespaces on this node and its ancestors.</p>

<p>Note that the keys in this hash <a href="../XML.html"><code>XML</code></a> attributes that would be used to define this namespace, such as “xmlns:prefix”, not just the prefix.</p>

<p>The default namespace for this node will be included with key “xmlns”.</p>

<p>See also <a href="Node.html#method-i-namespace_scopes"><code>#namespace_scopes</code></a></p>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Hash containing all the namespaces on this node and its ancestors. The hash keys are the namespace prefix, and the hash value for each key is the namespace URI.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns="http://example.com/root" xmlns:in_scope="http://example.com/in_scope"&gt;
    &lt;first/&gt;
    &lt;second xmlns="http://example.com/child"/&gt;
    &lt;third xmlns:foo="http://example.com/foo"/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//root:first"</span>, <span class="ruby-string">"root"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/root"</span>).<span class="ruby-identifier">namespaces</span>
<span class="ruby-comment"># =&gt; {"xmlns"=&gt;"http://example.com/root",</span>
<span class="ruby-comment">#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//child:second"</span>, <span class="ruby-string">"child"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/child"</span>).<span class="ruby-identifier">namespaces</span>
<span class="ruby-comment"># =&gt; {"xmlns"=&gt;"http://example.com/child",</span>
<span class="ruby-comment">#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_xpath</span>(<span class="ruby-string">"//root:third"</span>, <span class="ruby-string">"root"</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">"http://example.com/root"</span>).<span class="ruby-identifier">namespaces</span>
<span class="ruby-comment"># =&gt; {"xmlns:foo"=&gt;"http://example.com/foo",</span>
<span class="ruby-comment">#     "xmlns"=&gt;"http://example.com/root",</span>
<span class="ruby-comment">#     "xmlns:in_scope"=&gt;"http://example.com/in_scope"}</span>
</pre>

          <div class="method-source-code" id="namespaces-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1022</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespaces</span>
  <span class="ruby-identifier">namespace_scopes</span>.<span class="ruby-identifier">each_with_object</span>({}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ns</span>, <span class="ruby-identifier">hash</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prefix</span> = <span class="ruby-identifier">ns</span>.<span class="ruby-identifier">prefix</span>
    <span class="ruby-identifier">key</span> = <span class="ruby-identifier">prefix</span> <span class="ruby-operator">?</span> <span class="ruby-node">"xmlns:#{prefix}"</span> <span class="ruby-operator">:</span> <span class="ruby-string">"xmlns"</span>
    <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">ns</span>.<span class="ruby-identifier">href</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-native_content-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            content=
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the content for this <a href="Node.html"><code>Node</code></a></p>

          <div class="method-source-code" id="native_content-3D-source">
            <pre>static VALUE
set_native_content(VALUE self, VALUE content)
{
  xmlNodePtr node, child, next ;
  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  while (NULL != child) {
    next = child-&gt;next ;
    xmlUnlinkNode(child) ;
    noko_xml_document_pin_node(child);
    child = next ;
  }

  xmlNodeSetContent(node, (xmlChar *)StringValueCStr(content));
  return content;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-next_element" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            next_element
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the next <a href="Element.html"><code>Nokogiri::XML::Element</code></a> type sibling node.</p>

          <div class="method-source-code" id="next_element-source">
            <pre>static VALUE
next_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = xmlNextElementSibling(node);
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-next_sibling" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">next_sibling</span><span class="method-args"></span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the next sibling node</p>

          <div class="method-source-code" id="next_sibling-source">
            <pre>static VALUE
next_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;next;
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling) ;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-next">next</a>
        </div>

      </div>

      <div id="method-i-node_name" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">node_name</span><span class="method-args"></span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the name for this <a href="Node.html"><code>Node</code></a></p>

          <div class="method-source-code" id="node_name-source">
            <pre>static VALUE
get_name(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if (node-&gt;name) {
    return NOKOGIRI_STR_NEW2(node-&gt;name);
  }
  return Qnil;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-name">name</a>
        </div>

      </div>

      <div id="method-i-node_name-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">node_name=</span><span class="method-args">(new_name)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the name for this <a href="Node.html"><code>Node</code></a></p>

          <div class="method-source-code" id="node_name-3D-source">
            <pre>static VALUE
set_name(VALUE self, VALUE new_name)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlNodeSetName(node, (xmlChar *)StringValueCStr(new_name));
  return new_name;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-name-3D">name=</a>
        </div>

      </div>

      <div id="method-i-node_type" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">node_type</span><span class="method-args"></span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get the type for this <a href="Node.html"><code>Node</code></a></p>

          <div class="method-source-code" id="node_type-source">
            <pre>static VALUE
node_type(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return INT2NUM((long)node-&gt;type);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-type">type</a>
        </div>

      </div>

      <div id="method-i-parent" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            parent
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get the parent <a href="Node.html"><code>Node</code></a> for this <a href="Node.html"><code>Node</code></a></p>

          <div class="method-source-code" id="parent-source">
            <pre>static VALUE
get_parent(VALUE self)
{
  xmlNodePtr node, parent;
  Data_Get_Struct(self, xmlNode, node);

  parent = node-&gt;parent;
  if (!parent) { return Qnil; }

  return noko_xml_node_wrap(Qnil, parent) ;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-parse" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">parse</span><span class="method-args">(string_or_io, options = nil) { |options| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Parse <code>string_or_io</code> as a document fragment within the context of <strong>this</strong> node.  Returns a <a href="NodeSet.html"><code>XML::NodeSet</code></a> containing the nodes parsed from <code>string_or_io</code>.</p>

          <div class="method-source-code" id="parse-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 936</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parse</span>(<span class="ruby-identifier">string_or_io</span>, <span class="ruby-identifier">options</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-comment">##</span>
  <span class="ruby-comment"># When the current node is unparented and not an element node, use the</span>
  <span class="ruby-comment"># document as the parsing context instead. Otherwise, the in-context</span>
  <span class="ruby-comment"># parser cannot find an element or a document node.</span>
  <span class="ruby-comment"># Document Fragments are also not usable by the in-context parser.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">element?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">document?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">parent</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">fragment?</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">string_or_io</span>, <span class="ruby-identifier">options</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">options</span> <span class="ruby-operator">||=</span> (<span class="ruby-identifier">document</span>.<span class="ruby-identifier">html?</span> <span class="ruby-operator">?</span> <span class="ruby-constant">ParseOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_HTML</span> <span class="ruby-operator">:</span> <span class="ruby-constant">ParseOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_XML</span>)
  <span class="ruby-identifier">options</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseOptions</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">options</span>) <span class="ruby-keyword">if</span> <span class="ruby-constant">Integer</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">options</span>
  <span class="ruby-keyword">yield</span> <span class="ruby-identifier">options</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-identifier">contents</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">string_or_io</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:read</span>)
    <span class="ruby-identifier">string_or_io</span>.<span class="ruby-identifier">read</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">string_or_io</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">NodeSet</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">document</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">contents</span>.<span class="ruby-identifier">empty?</span>

  <span class="ruby-comment"># libxml2 does not obey the +recover+ option after encountering errors during +in_context+</span>
  <span class="ruby-comment"># parsing, and so this horrible hack is here to try to emulate recovery behavior.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># Unfortunately, this means we're no longer parsing "in context" and so namespaces that</span>
  <span class="ruby-comment"># would have been inherited from the context node won't be handled correctly. This hack was</span>
  <span class="ruby-comment"># written in 2010, and I regret it, because it's silently degrading functionality in a way</span>
  <span class="ruby-comment"># that's not easily prevented (or even detected).</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># I think preferable behavior would be to either:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># a. add an error noting that we "fell back" and pointing the user to turning off the +recover+ option</span>
  <span class="ruby-comment"># b. don't recover, but raise a sensible exception</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># For context and background: https://github.com/sparklemotion/nokogiri/issues/313</span>
  <span class="ruby-comment"># FIXME bug report: https://github.com/sparklemotion/nokogiri/issues/2092</span>
  <span class="ruby-identifier">error_count</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">length</span>
  <span class="ruby-identifier">node_set</span> = <span class="ruby-identifier">in_context</span>(<span class="ruby-identifier">contents</span>, <span class="ruby-identifier">options</span>.<span class="ruby-identifier">to_i</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">node_set</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">document</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">error_count</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">recover?</span>
      <span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">related_class</span>(<span class="ruby-string">"DocumentFragment"</span>).<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">contents</span>)
      <span class="ruby-identifier">node_set</span> = <span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">children</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">errors</span>[<span class="ruby-identifier">error_count</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">node_set</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-path" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            path
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the path associated with this <a href="Node.html"><code>Node</code></a></p>

          <div class="method-source-code" id="path-source">
            <pre>static VALUE
rb_xml_node_path(VALUE rb_node)
{
  xmlNodePtr c_node;
  xmlChar *c_path ;
  VALUE rval;

  Data_Get_Struct(rb_node, xmlNode, c_node);

  c_path = xmlGetNodePath(c_node);
  if (c_path == NULL) {
    // see https://github.com/sparklemotion/nokogiri/issues/2250
    // this behavior is clearly undesirable, but is what libxml &lt;= 2.9.10 returned, and so we
    // do this for now to preserve the behavior across libxml2 versions.
    rval = NOKOGIRI_STR_NEW2("?");
  } else {
    rval = NOKOGIRI_STR_NEW2(c_path);
    xmlFree(c_path);
  }

  return rval ;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-pointer_id" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            pointer_id() → Integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>A unique id for this node based on the internal memory structures. This method is used by <a href="Node.html#method-i-3D-3D"><code>#==</code></a> to determine node identity.</p>
</dd>
</dl>

          <div class="method-source-code" id="pointer_id-source">
            <pre>static VALUE
rb_xml_node_pointer_id(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);

  return INT2NUM((long)(node));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-previous_element" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            previous_element
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the previous <a href="Element.html"><code>Nokogiri::XML::Element</code></a> type sibling node.</p>

          <div class="method-source-code" id="previous_element-source">
            <pre>static VALUE
previous_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  /*
   *  note that we don't use xmlPreviousElementSibling here because it's buggy pre-2.7.7.
   */
  sibling = node-&gt;prev;
  if (!sibling) { return Qnil; }

  while (sibling &amp;&amp; sibling-&gt;type != XML_ELEMENT_NODE) {
    sibling = sibling-&gt;prev;
  }

  return sibling ? noko_xml_node_wrap(Qnil, sibling) : Qnil ;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-previous_sibling" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">previous_sibling</span><span class="method-args"></span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns the previous sibling node</p>

          <div class="method-source-code" id="previous_sibling-source">
            <pre>static VALUE
previous_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;prev;
  if (!sibling) { return Qnil; }

  return noko_xml_node_wrap(Qnil, sibling);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-previous">previous</a>
        </div>

      </div>

      <div id="method-i-processing_instruction-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">processing_instruction?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is a <a href="ProcessingInstruction.html"><code>ProcessingInstruction</code></a> node</p>

          <div class="method-source-code" id="processing_instruction-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1056</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">processing_instruction?</span>
  <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">PI_NODE</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-read_only-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">read_only?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Is this a read only node?</p>

          <div class="method-source-code" id="read_only-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1080</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read_only?</span>
  <span class="ruby-comment"># According to gdome2, these are read-only node types</span>
  [<span class="ruby-constant">NOTATION_NODE</span>, <span class="ruby-constant">ENTITY_NODE</span>, <span class="ruby-constant">ENTITY_DECL</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">type</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-text" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            text() → String
          </span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-content">content</a>
        </div>
      </div>

      <div id="method-i-text-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">text?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is a <a href="Text.html"><code>Text</code></a> node</p>

          <div class="method-source-code" id="text-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1061</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">text?</span>
  <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">TEXT_NODE</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_s" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">to_s</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Turn this node in to a string.  If the document is <a href="../HTML4.html"><code>HTML</code></a>, this method returns html.  If the document is <a href="../XML.html"><code>XML</code></a>, this method returns <a href="../XML.html"><code>XML</code></a>.</p>

          <div class="method-source-code" id="to_s-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1095</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_s</span>
  <span class="ruby-identifier">document</span>.<span class="ruby-identifier">xml?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">to_xml</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">to_html</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_str" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            to_str() → String
          </span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-content">content</a>
        </div>
      </div>

      <div id="method-i-traverse" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">traverse</span><span class="method-args">() { |self| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Yields self and all children to <code>block</code> recursively.</p>

          <div class="method-source-code" id="traverse-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">traverse</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">children</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span> <span class="ruby-identifier">j</span>.<span class="ruby-identifier">traverse</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) }
  <span class="ruby-keyword">yield</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-type" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">type</span><span class="method-args">()</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-node_type">node_type</a>
        </div>
      </div>

      <div id="method-i-unlink" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            unlink() → self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Unlink this node from its current context.</p>

          <div class="method-source-code" id="unlink-source">
            <pre>static VALUE
unlink_node(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlUnlinkNode(node);
  noko_xml_document_pin_node(node);
  return self;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-remove">remove</a>
        </div>

      </div>

      <div id="method-i-xml-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">xml?</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Returns true if this is an <a href="Document.html"><code>XML::Document</code></a> node</p>

          <div class="method-source-code" id="xml-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1041</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">xml?</span>
  <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-constant">DOCUMENT_NODE</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Protected Instance Methods</h3>
       </header>

      <div id="method-i-coerce" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">coerce</span><span class="method-args">(data)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          

          <div class="method-source-code" id="coerce-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1312</span>
      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">coerce</span>(<span class="ruby-identifier">data</span>)
        <span class="ruby-keyword">case</span> <span class="ruby-identifier">data</span>
        <span class="ruby-keyword">when</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">NodeSet</span>
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">data</span>
        <span class="ruby-keyword">when</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">DocumentFragment</span>
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">data</span>.<span class="ruby-identifier">children</span>
        <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragment</span>(<span class="ruby-identifier">data</span>).<span class="ruby-identifier">children</span>
        <span class="ruby-keyword">when</span> <span class="ruby-constant">Document</span>, <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Attr</span>
          <span class="ruby-comment"># unacceptable</span>
        <span class="ruby-keyword">when</span> <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">data</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-identifier">&lt;&lt;~EOERR</span>
<span class="ruby-value">          Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.
          (You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)
</span><span class="ruby-identifier">        EOERR</span>
      <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
  <section id="Manipulating+Document+Structure" class="documentation-section">
    <header class="documentation-section-title">
      <h2 id="Manipulating+Document+Structure">
        Manipulating Document Structure
      </h2>
      <span class="section-click-top">
        <a href="#top">↑ top</a>
      </span>
    </header>





     <section id="public-instance-Manipulating+Document+Structure-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-3C-3C" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">&lt;&lt;</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Add <code>node_or_tags</code> as a child of this <a href="Node.html"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns self, to support chaining of calls (e.g., root &lt;&lt; child1 &lt;&lt; child2)</p>

<p>Also see related method <code>add_child</code>.</p>

          <div class="method-source-code" id="3C-3C-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 190</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">add_child</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-add_child" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">add_child</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Add <code>node_or_tags</code> as a child of this <a href="Node.html"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="Node.html"><code>Node</code></a>), or <a href="NodeSet.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="DocumentFragment.html"><code>DocumentFragment</code></a>, <a href="NodeSet.html"><code>NodeSet</code></a>, or string).</p>

<p>Also see related method +&lt;&lt;+.</p>

          <div class="method-source-code" id="add_child-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 145</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_child</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">node_or_tags</span> = <span class="ruby-identifier">coerce</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">NodeSet</span>)
    <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">add_child_node_and_reparent_attrs</span>(<span class="ruby-identifier">n</span>) }
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">add_child_node_and_reparent_attrs</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">node_or_tags</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-add_namespace" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            add_namespace(prefix, href) → Nokogiri::XML::Namespace
          </span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-add_namespace_definition">add_namespace_definition</a>
        </div>
      </div>

      <div id="method-i-add_namespace_definition" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">add_namespace_definition</span><span class="method-args">(prefix, href) → Nokogiri::XML::Namespace</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Adds a namespace definition to this node with <code>prefix</code> using <code>href</code> value, as if this node had included an attribute “xmlns:prefix=href”.</p>

<p>A default namespace definition for this node can be added by passing <code>nil</code> for <code>prefix</code>.</p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul>
<li>
<p><code>prefix</code> (String, <code>nil</code>) An <a href="https://www.w3.org/TR/xml-names/#ns-decl">XML Name</a></p>
</li>
<li>
<p><code>href</code> (String) The <a href="https://www.w3.org/TR/xml-names/#sec-namespaces">URI reference</a></p>
</li>
</ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>The new <a href="Namespace.html"><code>Nokogiri::XML::Namespace</code></a></p>
</dd>
</dl>

<p><strong>Example:</strong> adding a non-default namespace definition</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-string">"&lt;store&gt;&lt;inventory&gt;&lt;/inventory&gt;&lt;/store&gt;"</span>)
<span class="ruby-identifier">inventory</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"inventory"</span>)
<span class="ruby-identifier">inventory</span>.<span class="ruby-identifier">add_namespace_definition</span>(<span class="ruby-string">"automobile"</span>, <span class="ruby-string">"http://alices-autos.com/"</span>)
<span class="ruby-identifier">inventory</span>.<span class="ruby-identifier">add_namespace_definition</span>(<span class="ruby-string">"bicycle"</span>, <span class="ruby-string">"http://bobs-bikes.com/"</span>)
<span class="ruby-identifier">inventory</span>.<span class="ruby-identifier">add_child</span>(<span class="ruby-string">"&lt;automobile:tire&gt;Michelin model XGV, size 75R&lt;/automobile:tire&gt;"</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">to_xml</span>
<span class="ruby-comment"># =&gt; "&lt;?xml version=\"1.0\"?&gt;\n" +</span>
<span class="ruby-comment">#    "&lt;store&gt;\n" +</span>
<span class="ruby-comment">#    "  &lt;inventory xmlns:automobile=\"http://alices-autos.com/\" xmlns:bicycle=\"http://bobs-bikes.com/\"&gt;\n" +</span>
<span class="ruby-comment">#    "    &lt;automobile:tire&gt;Michelin model XGV, size 75R&lt;/automobile:tire&gt;\n" +</span>
<span class="ruby-comment">#    "  &lt;/inventory&gt;\n" +</span>
<span class="ruby-comment">#    "&lt;/store&gt;\n"</span>
</pre>

<p><strong>Example:</strong> adding a default namespace definition</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-string">"&lt;store&gt;&lt;inventory&gt;&lt;tire&gt;Michelin model XGV, size 75R&lt;/tire&gt;&lt;/inventory&gt;&lt;/store&gt;"</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"tire"</span>).<span class="ruby-identifier">add_namespace_definition</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-string">"http://bobs-bikes.com/"</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">to_xml</span>
<span class="ruby-comment"># =&gt; "&lt;?xml version=\"1.0\"?&gt;\n" +</span>
<span class="ruby-comment">#    "&lt;store&gt;\n" +</span>
<span class="ruby-comment">#    "  &lt;inventory&gt;\n" +</span>
<span class="ruby-comment">#    "    &lt;tire xmlns=\"http://bobs-bikes.com/\"&gt;Michelin model XGV, size 75R&lt;/tire&gt;\n" +</span>
<span class="ruby-comment">#    "  &lt;/inventory&gt;\n" +</span>
<span class="ruby-comment">#    "&lt;/store&gt;\n"</span>
</pre>

          <div class="method-source-code" id="add_namespace_definition-source">
            <pre>static VALUE
rb_xml_node_add_namespace_definition(VALUE rb_node, VALUE rb_prefix, VALUE rb_href)
{
  xmlNodePtr c_node, element;
  xmlNsPtr c_namespace;
  const xmlChar *c_prefix = (const xmlChar *)(NIL_P(rb_prefix) ? NULL : StringValueCStr(rb_prefix));

  Data_Get_Struct(rb_node, xmlNode, c_node);
  element = c_node ;

  c_namespace = xmlSearchNs(c_node-&gt;doc, c_node, c_prefix);

  if (!c_namespace) {
    if (c_node-&gt;type != XML_ELEMENT_NODE) {
      element = c_node-&gt;parent;
    }
    c_namespace = xmlNewNs(element, (const xmlChar *)StringValueCStr(rb_href), c_prefix);
  }

  if (!c_namespace) {
    return Qnil ;
  }

  if (NIL_P(rb_prefix) || c_node != element) {
    xmlSetNs(c_node, c_namespace);
  }

  return noko_xml_namespace_wrap(c_namespace, c_node-&gt;doc);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-add_namespace">add_namespace</a>
        </div>

      </div>

      <div id="method-i-add_next_sibling" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">add_next_sibling</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Insert <code>node_or_tags</code> after this <a href="Node.html"><code>Node</code></a> (as a sibling). <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="Node.html"><code>Node</code></a>), or <a href="NodeSet.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="DocumentFragment.html"><code>DocumentFragment</code></a>, <a href="NodeSet.html"><code>NodeSet</code></a>, or string).</p>

<p>Also see related method <code>after</code>.</p>

          <div class="method-source-code" id="add_next_sibling-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 216</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_next_sibling</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>,
    <span class="ruby-string">"A document may not have multiple root nodes."</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>&amp;.<span class="ruby-identifier">document?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">comment?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">processing_instruction?</span>)

  <span class="ruby-identifier">add_sibling</span>(<span class="ruby-value">:next</span>, <span class="ruby-identifier">node_or_tags</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-next-3D">next=</a>
        </div>

      </div>

      <div id="method-i-add_previous_sibling" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">add_previous_sibling</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Insert <code>node_or_tags</code> before this <a href="Node.html"><code>Node</code></a> (as a sibling). <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="Node.html"><code>Node</code></a>), or <a href="NodeSet.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="DocumentFragment.html"><code>DocumentFragment</code></a>, <a href="NodeSet.html"><code>NodeSet</code></a>, or string).</p>

<p>Also see related method <code>before</code>.</p>

          <div class="method-source-code" id="add_previous_sibling-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 202</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_previous_sibling</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>,
    <span class="ruby-string">"A document may not have multiple root nodes."</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">parent</span>&amp;.<span class="ruby-identifier">document?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">comment?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">processing_instruction?</span>)

  <span class="ruby-identifier">add_sibling</span>(<span class="ruby-value">:previous</span>, <span class="ruby-identifier">node_or_tags</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-previous-3D">previous=</a>
        </div>

      </div>

      <div id="method-i-after" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">after</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Insert <code>node_or_tags</code> after this node (as a sibling). <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a <a href="DocumentFragment.html"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p>

<p>Returns self, to support chaining of calls.</p>

<p>Also see related method <code>add_next_sibling</code>.</p>

          <div class="method-source-code" id="after-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">after</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">add_next_sibling</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-before" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">before</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Insert <code>node_or_tags</code> before this node (as a sibling). <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns self, to support chaining of calls.</p>

<p>Also see related method <code>add_previous_sibling</code>.</p>

          <div class="method-source-code" id="before-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">before</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">add_previous_sibling</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-children-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">children=</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the inner html for this <a href="Node.html"><code>Node</code></a> <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a <a href="DocumentFragment.html"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p>

<p>Also see related method <code>inner_html=</code></p>

          <div class="method-source-code" id="children-3D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 261</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">children=</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">node_or_tags</span> = <span class="ruby-identifier">coerce</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">children</span>.<span class="ruby-identifier">unlink</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">NodeSet</span>)
    <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">add_child_node_and_reparent_attrs</span>(<span class="ruby-identifier">n</span>) }
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">add_child_node_and_reparent_attrs</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-content-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">content=</span><span class="method-args">(string)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the Node’s content to a <a href="Text.html"><code>Text</code></a> node containing <code>string</code>. The string gets <a href="../XML.html"><code>XML</code></a> escaped, not interpreted as markup.</p>

          <div class="method-source-code" id="content-3D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 317</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">content=</span>(<span class="ruby-identifier">string</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">native_content</span> = <span class="ruby-identifier">encode_special_chars</span>(<span class="ruby-identifier">string</span>.<span class="ruby-identifier">to_s</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-default_namespace-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">default_namespace=</span><span class="method-args">(url)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Adds a default namespace supplied as a string <code>url</code> href, to self. The consequence is as an xmlns attribute with supplied argument were present in parsed <a href="../XML.html"><code>XML</code></a>.  A default namespace set with this method will now show up in <a href="Node.html#method-i-attributes"><code>#attributes</code></a>, but when this node is serialized to <a href="../XML.html"><code>XML</code></a> an “xmlns” attribute will appear. See also <a href="Node.html#method-i-namespace"><code>#namespace</code></a> and <a href="Node.html#method-i-namespace-3D"><code>#namespace=</code></a></p>

          <div class="method-source-code" id="default_namespace-3D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 333</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">default_namespace=</span>(<span class="ruby-identifier">url</span>)
  <span class="ruby-identifier">add_namespace_definition</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">url</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-do_xinclude" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">do_xinclude</span><span class="method-args">(options = XML::ParseOptions::DEFAULT_XML) { |options| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Do xinclude substitution on the subtree below node. If given a block, a <a href="ParseOptions.html"><code>Nokogiri::XML::ParseOptions</code></a> object initialized from <code>options</code>, will be passed to it, allowing more convenient modification of the parser options.</p>

          <div class="method-source-code" id="do_xinclude-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 360</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">do_xinclude</span>(<span class="ruby-identifier">options</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_XML</span>)
  <span class="ruby-identifier">options</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">ParseOptions</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">options</span>) <span class="ruby-keyword">if</span> <span class="ruby-constant">Integer</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">options</span>
  <span class="ruby-keyword">yield</span> <span class="ruby-identifier">options</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-comment"># call c extension</span>
  <span class="ruby-identifier">process_xincludes</span>(<span class="ruby-identifier">options</span>.<span class="ruby-identifier">to_i</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-inner_html-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">inner_html=</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the inner html for this <a href="Node.html"><code>Node</code></a> to <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a <a href="DocumentFragment.html"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p>

<p>Also see related method <code>children=</code></p>

          <div class="method-source-code" id="inner_html-3D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 252</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">inner_html=</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">children</span> = <span class="ruby-identifier">node_or_tags</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-name-3D" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-callseq">
            name=(new_name)
          </span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-node_name-3D">node_name=</a>
        </div>
      </div>

      <div id="method-i-namespace-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">namespace=</span><span class="method-args">(ns)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the default namespace on this node (as would be defined with an “xmlns=” attribute in <a href="../XML.html"><code>XML</code></a> source), as a <a href="Namespace.html"><code>Namespace</code></a> object <code>ns</code>. Note that a <a href="Namespace.html"><code>Namespace</code></a> added this way will NOT be serialized as an xmlns attribute for this node. You probably want <a href="Node.html#method-i-default_namespace-3D"><code>#default_namespace=</code></a> instead, or perhaps <a href="Node.html#method-i-add_namespace_definition"><code>#add_namespace_definition</code></a> with a nil prefix argument.</p>

          <div class="method-source-code" id="namespace-3D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 343</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">namespace=</span>(<span class="ruby-identifier">ns</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">set_namespace</span>(<span class="ruby-identifier">ns</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ns</span>

  <span class="ruby-keyword">unless</span> <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Namespace</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">ns</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">TypeError</span>, <span class="ruby-node">"#{ns.class} can't be coerced into Nokogiri::XML::Namespace"</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">ns</span>.<span class="ruby-identifier">document</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">document</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">"namespace must be declared on the same document"</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">set_namespace</span>(<span class="ruby-identifier">ns</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-next" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">next</span><span class="method-args">()</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-next_sibling">next_sibling</a>
        </div>
      </div>

      <div id="method-i-next-3D" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">next=</span><span class="method-args">(node_or_tags)</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-add_next_sibling">add_next_sibling</a>
        </div>
      </div>

      <div id="method-i-parent-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">parent=</span><span class="method-args">(parent_node)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the parent <a href="Node.html"><code>Node</code></a> for this <a href="Node.html"><code>Node</code></a></p>

          <div class="method-source-code" id="parent-3D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 323</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">parent=</span>(<span class="ruby-identifier">parent_node</span>)
  <span class="ruby-identifier">parent_node</span>.<span class="ruby-identifier">add_child</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-prepend_child" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">prepend_child</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Add <code>node_or_tags</code> as the first child of this <a href="Node.html"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="Node.html"><code>Node</code></a>), or <a href="NodeSet.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="DocumentFragment.html"><code>DocumentFragment</code></a>, <a href="NodeSet.html"><code>NodeSet</code></a>, or string).</p>

<p>Also see related method <code>add_child</code>.</p>

          <div class="method-source-code" id="prepend_child-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 162</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">prepend_child</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">first</span> = <span class="ruby-identifier">children</span>.<span class="ruby-identifier">first</span>)
    <span class="ruby-comment"># Mimic the error add_child would raise.</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-string">"Document already has a root node"</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">document?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">comment?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">processing_instruction?</span>)
    <span class="ruby-identifier">first</span>.<span class="ruby-identifier">__send__</span>(<span class="ruby-value">:add_sibling</span>, <span class="ruby-value">:previous</span>, <span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">add_child</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-previous" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">previous</span><span class="method-args">()</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-previous_sibling">previous_sibling</a>
        </div>
      </div>

      <div id="method-i-previous-3D" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">previous=</span><span class="method-args">(node_or_tags)</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-add_previous_sibling">add_previous_sibling</a>
        </div>
      </div>

      <div id="method-i-remove" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">remove</span><span class="method-args">()</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-unlink">unlink</a>
        </div>
      </div>

      <div id="method-i-replace" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">replace</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Replace this <a href="Node.html"><code>Node</code></a> with <code>node_or_tags</code>. <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="Node.html"><code>Node</code></a>), or <a href="NodeSet.html"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="DocumentFragment.html"><code>DocumentFragment</code></a>, <a href="NodeSet.html"><code>NodeSet</code></a>, or string).</p>

<p>Also see related method <code>swap</code>.</p>

          <div class="method-source-code" id="replace-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 278</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">replace</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-string">"Cannot replace a node with no parent"</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parent</span>

  <span class="ruby-comment"># We cannot replace a text node directly, otherwise libxml will return</span>
  <span class="ruby-comment"># an internal error at parser.c:13031, I don't know exactly why</span>
  <span class="ruby-comment"># libxml is trying to find a parent node that is an element or document</span>
  <span class="ruby-comment"># so I can't tell if this is bug in libxml or not. issue #775.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">text?</span>
    <span class="ruby-identifier">replacee</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">"dummy"</span>, <span class="ruby-identifier">document</span>)
    <span class="ruby-identifier">add_previous_sibling_node</span>(<span class="ruby-identifier">replacee</span>)
    <span class="ruby-identifier">unlink</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">replacee</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">node_or_tags</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">coerce</span>(<span class="ruby-identifier">node_or_tags</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">NodeSet</span>)
    <span class="ruby-identifier">node_or_tags</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span> <span class="ruby-identifier">add_previous_sibling</span>(<span class="ruby-identifier">n</span>) }
    <span class="ruby-identifier">unlink</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">replace_node</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">node_or_tags</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-swap" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">swap</span><span class="method-args">(node_or_tags)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Swap this <a href="Node.html"><code>Node</code></a> for <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="Node.html"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p>

<p>Returns self, to support chaining of calls.</p>

<p>Also see related method <code>replace</code>.</p>

          <div class="method-source-code" id="swap-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 310</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">swap</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-identifier">replace</span>(<span class="ruby-identifier">node_or_tags</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-wrap" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">wrap</span><span class="method-args">(html)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Add html around this node</p>

<p>Returns self</p>

          <div class="method-source-code" id="wrap-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wrap</span>(<span class="ruby-identifier">html</span>)
  <span class="ruby-identifier">new_parent</span> = <span class="ruby-identifier">document</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">html</span>).<span class="ruby-identifier">first</span>
  <span class="ruby-identifier">add_next_sibling</span>(<span class="ruby-identifier">new_parent</span>)
  <span class="ruby-identifier">new_parent</span>.<span class="ruby-identifier">add_child</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
  <section id="Serialization+and+Generating+Output" class="documentation-section">
    <header class="documentation-section-title">
      <h2 id="Serialization+and+Generating+Output">
        Serialization and Generating Output
      </h2>
      <span class="section-click-top">
        <a href="#top">↑ top</a>
      </span>
    </header>





     <section id="public-instance-Serialization+and+Generating+Output-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-canonicalize" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">canonicalize</span><span class="method-args">(mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          

          <div class="method-source-code" id="canonicalize-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1300</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">canonicalize</span>(<span class="ruby-identifier">mode</span> = <span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">XML_C14N_1_0</span>, <span class="ruby-identifier">inclusive_namespaces</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">with_comments</span> = <span class="ruby-keyword">false</span>)
  <span class="ruby-identifier">c14n_root</span> = <span class="ruby-keyword">self</span>
  <span class="ruby-identifier">document</span>.<span class="ruby-identifier">canonicalize</span>(<span class="ruby-identifier">mode</span>, <span class="ruby-identifier">inclusive_namespaces</span>, <span class="ruby-identifier">with_comments</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span>, <span class="ruby-identifier">parent</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">tn</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">XML</span><span class="ruby-operator">::</span><span class="ruby-constant">Node</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">node</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">parent</span>
    <span class="ruby-identifier">tn</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">c14n_root</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tn</span>.<span class="ruby-identifier">ancestors</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">c14n_root</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-serialize" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">serialize</span><span class="method-args">(*args, &amp;block)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Serialize <a href="Node.html"><code>Node</code></a> using <code>options</code>.  Save options can also be set using a block. See <a href="Node/SaveOptions.html"><code>SaveOptions</code></a>.</p>

<p>These two statements are equivalent:</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">serialize</span>(<span class="ruby-value">:encoding</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">'UTF-8'</span>, <span class="ruby-value">:save_with</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-constant">FORMAT</span> <span class="ruby-operator">|</span> <span class="ruby-constant">AS_XML</span>)
</pre>

<p>or</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">serialize</span>(<span class="ruby-value">:encoding</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">'UTF-8'</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">config</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">config</span>.<span class="ruby-identifier">format</span>.<span class="ruby-identifier">as_xml</span>
<span class="ruby-keyword">end</span>
</pre>

          <div class="method-source-code" id="serialize-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1181</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">serialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">options</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)
    <span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>
  <span class="ruby-keyword">else</span>
    {
      <span class="ruby-value">encoding:</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>],
      <span class="ruby-value">save_with:</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">1</span>],
    }
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:encoding</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">encoding</span>
  <span class="ruby-identifier">options</span>[<span class="ruby-value">:encoding</span>] = <span class="ruby-identifier">encoding</span>

  <span class="ruby-identifier">outstring</span> = <span class="ruby-string">+""</span>
  <span class="ruby-identifier">outstring</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">encoding</span> <span class="ruby-operator">||</span> <span class="ruby-string">"utf-8"</span>))
  <span class="ruby-identifier">io</span> = <span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">outstring</span>)
  <span class="ruby-identifier">write_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">io</span>.<span class="ruby-identifier">string</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_html" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">to_html</span><span class="method-args">(options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Serialize this <a href="Node.html"><code>Node</code></a> to <a href="../HTML4.html"><code>HTML</code></a></p>

<pre class="ruby"><span class="ruby-identifier">doc</span>.<span class="ruby-identifier">to_html</span>
</pre>

<p>See <a href="Node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code>.  For formatted output, use <a href="Node.html#method-i-to_xhtml"><code>Node#to_xhtml</code></a> instead.</p>

          <div class="method-source-code" id="to_html-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_html</span>(<span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">to_format</span>(<span class="ruby-constant">SaveOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_HTML</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_xhtml" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">to_xhtml</span><span class="method-args">(options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Serialize this <a href="Node.html"><code>Node</code></a> to XHTML using <code>options</code></p>

<pre class="ruby"><span class="ruby-identifier">doc</span>.<span class="ruby-identifier">to_xhtml</span>(<span class="ruby-value">:indent</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">5</span>, <span class="ruby-value">:encoding</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">'UTF-8'</span>)
</pre>

<p>See <a href="Node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>

          <div class="method-source-code" id="to_xhtml-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_xhtml</span>(<span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">to_format</span>(<span class="ruby-constant">SaveOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_XHTML</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_xml" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">to_xml</span><span class="method-args">(options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Serialize this <a href="Node.html"><code>Node</code></a> to <a href="../XML.html"><code>XML</code></a> using <code>options</code></p>

<pre class="ruby"><span class="ruby-identifier">doc</span>.<span class="ruby-identifier">to_xml</span>(<span class="ruby-value">:indent</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">5</span>, <span class="ruby-value">:encoding</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">'UTF-8'</span>)
</pre>

<p>See <a href="Node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>

          <div class="method-source-code" id="to_xml-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_xml</span>(<span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">options</span>[<span class="ruby-value">:save_with</span>] <span class="ruby-operator">||=</span> <span class="ruby-constant">SaveOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_XML</span>
  <span class="ruby-identifier">serialize</span>(<span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-write_html_to" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">write_html_to</span><span class="method-args">(io, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Write <a href="Node.html"><code>Node</code></a> as <a href="../HTML4.html"><code>HTML</code></a> to <code>io</code> with <code>options</code></p>

<p>See <a href="Node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>

          <div class="method-source-code" id="write_html_to-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1277</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_html_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">write_format_to</span>(<span class="ruby-constant">SaveOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_HTML</span>, <span class="ruby-identifier">io</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-write_to" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">write_to</span><span class="method-args">(io, *options) { |config| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Write <a href="Node.html"><code>Node</code></a> to <code>io</code> with <code>options</code>. <code>options</code> modify the output of this method.  Valid options are:</p>
<ul>
<li>
<p><code>:encoding</code> for changing the encoding</p>
</li>
<li>
<p><code>:indent_text</code> the indentation text, defaults to one space</p>
</li>
<li>
<p><code>:indent</code> the number of <code>:indent_text</code> to use, defaults to 2</p>
</li>
<li>
<p><code>:save_with</code> a combination of <a href="Node/SaveOptions.html"><code>SaveOptions</code></a> constants.</p>
</li>
</ul>

<p>To save with UTF-8 indented twice:</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">write_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-value">:encoding</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">'UTF-8'</span>, <span class="ruby-value">:indent</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">2</span>)
</pre>

<p>To save indented with two dashes:</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">write_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-value">:indent_text</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">'-'</span>, <span class="ruby-value">:indent</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">2</span>)
</pre>

          <div class="method-source-code" id="write_to-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1250</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">options</span>)
  <span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">:</span> {}
  <span class="ruby-identifier">encoding</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:encoding</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">0</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-constant">Nokogiri</span>.<span class="ruby-identifier">jruby?</span>
    <span class="ruby-identifier">save_options</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:save_with</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">1</span>]
    <span class="ruby-identifier">indent_times</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:indent</span>] <span class="ruby-operator">||</span> <span class="ruby-value">0</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">save_options</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:save_with</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">SaveOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">FORMAT</span>
    <span class="ruby-identifier">indent_times</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:indent</span>] <span class="ruby-operator">||</span> <span class="ruby-value">2</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">indent_text</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:indent_text</span>] <span class="ruby-operator">||</span> <span class="ruby-string">" "</span>

  <span class="ruby-comment"># Any string times 0 returns an empty string. Therefore, use the same</span>
  <span class="ruby-comment"># string instead of generating a new empty string for every node with</span>
  <span class="ruby-comment"># zero indentation.</span>
  <span class="ruby-identifier">indentation</span> = <span class="ruby-identifier">indent_times</span>.<span class="ruby-identifier">zero?</span> <span class="ruby-operator">?</span> <span class="ruby-string">""</span> <span class="ruby-operator">:</span> (<span class="ruby-identifier">indent_text</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">indent_times</span>)

  <span class="ruby-identifier">config</span> = <span class="ruby-constant">SaveOptions</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">save_options</span>.<span class="ruby-identifier">to_i</span>)
  <span class="ruby-keyword">yield</span> <span class="ruby-identifier">config</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-identifier">native_write_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">encoding</span>, <span class="ruby-identifier">indentation</span>, <span class="ruby-identifier">config</span>.<span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-write_xhtml_to" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">write_xhtml_to</span><span class="method-args">(io, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Write <a href="Node.html"><code>Node</code></a> as XHTML to <code>io</code> with <code>options</code></p>

<p>See <a href="Node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>

          <div class="method-source-code" id="write_xhtml_to-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1285</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_xhtml_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">write_format_to</span>(<span class="ruby-constant">SaveOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_XHTML</span>, <span class="ruby-identifier">io</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-write_xml_to" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">write_xml_to</span><span class="method-args">(io, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Write <a href="Node.html"><code>Node</code></a> as <a href="../XML.html"><code>XML</code></a> to <code>io</code> with <code>options</code></p>

<pre class="ruby"><span class="ruby-identifier">doc</span>.<span class="ruby-identifier">write_xml_to</span> <span class="ruby-identifier">io</span>, <span class="ruby-value">:encoding</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">'UTF-8'</span>
</pre>

<p>See <a href="Node.html#method-i-write_to"><code>Node#write_to</code></a> for a list of options</p>

          <div class="method-source-code" id="write_xml_to-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 1295</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write_xml_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">options</span>[<span class="ruby-value">:save_with</span>] <span class="ruby-operator">||=</span> <span class="ruby-constant">SaveOptions</span><span class="ruby-operator">::</span><span class="ruby-constant">DEFAULT_XML</span>
  <span class="ruby-identifier">write_to</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
  <section id="Traversing+Document+Structure" class="documentation-section">
    <header class="documentation-section-title">
      <h2 id="Traversing+Document+Structure">
        Traversing Document Structure
      </h2>
      <span class="section-click-top">
        <a href="#top">↑ top</a>
      </span>
    </header>





     <section id="public-instance-Traversing+Document+Structure-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-child" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            child() → Nokogiri::XML::Node
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>First of this node’s children, or <code>nil</code> if there are no children</p>
</dd>
</dl>

<p>This is a convenience method and is equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">first</span>
</pre>

<p>See related: <a href="Node.html#method-i-children"><code>#children</code></a></p>

          <div class="method-source-code" id="child-source">
            <pre>static VALUE
rb_xml_node_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  if (!child) { return Qnil; }

  return noko_xml_node_wrap(Qnil, child);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-children" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            children() → Nokogiri::XML::NodeSet
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><a href="NodeSet.html"><code>Nokogiri::XML::NodeSet</code></a> containing this node’s children.</p>
</dd>
</dl>

          <div class="method-source-code" id="children-source">
            <pre>static VALUE
rb_xml_node_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if (!child) { return noko_xml_node_set_wrap(set, document); }

  child = child-&gt;next;
  while (NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = child-&gt;next;
  }

  node_set = noko_xml_node_set_wrap(set, document);

  return node_set;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-document" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            document() → Nokogiri::XML::Document
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Parent <a href="Document.html"><code>Nokogiri::XML::Document</code></a> for this node</p>
</dd>
</dl>

          <div class="method-source-code" id="document-source">
            <pre>static VALUE
rb_xml_node_document(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return DOC_RUBY_OBJECT(node-&gt;doc);
}</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
  <section id="Working+With+Node+Attributes" class="documentation-section">
    <header class="documentation-section-title">
      <h2 id="Working+With+Node+Attributes">
        Working With Node Attributes
      </h2>
      <span class="section-click-top">
        <a href="#top">↑ top</a>
      </span>
    </header>





     <section id="public-instance-Working+With+Node+Attributes-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-5B-5D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            [](name) → (String, nil)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Fetch an attribute from this node.</p>

<p>⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes, use <a href="Node.html#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>.</p>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>(String, nil) value of the attribute <code>name</code>, or <code>nil</code> if no matching attribute exists</p>
</dd>
</dl>

<p><strong>Example</strong></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-string">"&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;"</span>)
<span class="ruby-identifier">child</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>)
<span class="ruby-identifier">child</span>[<span class="ruby-string">"size"</span>] <span class="ruby-comment"># =&gt; "large"</span>
<span class="ruby-identifier">child</span>[<span class="ruby-string">"class"</span>] <span class="ruby-comment"># =&gt; "big wide tall"</span>
</pre>

<p><strong>Example:</strong> Namespaced attributes will not be returned.</p>

<p>⚠ Note namespaced attributes may be accessed with <a href="Node.html#method-i-attribute"><code>#attribute</code></a> or <a href="Node.html#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns:width='http://example.com/widths'&gt;
    &lt;child width:size='broad'/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>)[<span class="ruby-string">"size"</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attribute</span>(<span class="ruby-string">"size"</span>).<span class="ruby-identifier">value</span> <span class="ruby-comment"># =&gt; "broad"</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attribute_with_ns</span>(<span class="ruby-string">"size"</span>, <span class="ruby-string">"http://example.com/widths"</span>).<span class="ruby-identifier">value</span>
<span class="ruby-comment"># =&gt; "broad"</span>
</pre>

          <div class="method-source-code" id="5B-5D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 418</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-identifier">get</span>(<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-get_attribute">get_attribute</a>, <a href="Node.html#method-i-attr">attr</a>
        </div>

      </div>

      <div id="method-i-5B-5D-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            []=(name, value) → value
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Update the attribute <code>name</code> to <code>value</code>, or create the attribute if it does not exist.</p>

<p>⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes for update, use <a href="Node.html#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>. To add a namespaced attribute, see the example below.</p>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><code>value</code></p>
</dd>
</dl>

<p><strong>Example</strong></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-string">"&lt;root&gt;&lt;child/&gt;&lt;/root&gt;"</span>)
<span class="ruby-identifier">child</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>)
<span class="ruby-identifier">child</span>[<span class="ruby-string">"size"</span>] = <span class="ruby-string">"broad"</span>
<span class="ruby-identifier">child</span>.<span class="ruby-identifier">to_html</span>
<span class="ruby-comment"># =&gt; "&lt;child size=\"broad\"&gt;&lt;/child&gt;"</span>
</pre>

<p><strong>Example:</strong> Add a namespaced attribute.</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns:width='http://example.com/widths'&gt;
    &lt;child/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">child</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>)
<span class="ruby-identifier">child</span>[<span class="ruby-string">"size"</span>] = <span class="ruby-string">"broad"</span>
<span class="ruby-identifier">ns</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">root</span>.<span class="ruby-identifier">namespace_definitions</span>.<span class="ruby-identifier">find</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">ns</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ns</span>.<span class="ruby-identifier">prefix</span> <span class="ruby-operator">==</span> <span class="ruby-string">"width"</span> }
<span class="ruby-identifier">child</span>.<span class="ruby-identifier">attribute</span>(<span class="ruby-string">"size"</span>).<span class="ruby-identifier">namespace</span> = <span class="ruby-identifier">ns</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">to_html</span>
<span class="ruby-comment"># =&gt; "&lt;root xmlns:width=\"http://example.com/widths\"&gt;\n" +</span>
<span class="ruby-comment">#    "  &lt;child width:size=\"broad\"&gt;&lt;/child&gt;\n" +</span>
<span class="ruby-comment">#    "&lt;/root&gt;\n"</span>
</pre>

          <div class="method-source-code" id="5B-5D-3D-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 456</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">[]=</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">set</span>(<span class="ruby-identifier">name</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">value</span>.<span class="ruby-identifier">to_s</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-set_attribute">set_attribute</a>
        </div>

      </div>

      <div id="method-i-add_class" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            add_class(names) → self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Ensure <a href="../HTML4.html"><code>HTML</code></a> <a href="../CSS.html"><code>CSS</code></a> classes are present on <code>self</code>. Any <a href="../CSS.html"><code>CSS</code></a> classes in <code>names</code> that already exist in the “class” attribute are <em>not</em> added. Note that any existing duplicates in the “class” attribute are not removed. Compare with <a href="Node.html#method-i-append_class"><code>#append_class</code></a>.</p>

<p>This is a convenience function and is equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_add</span>(<span class="ruby-string">"class"</span>, <span class="ruby-identifier">names</span>)
</pre>

<p>See related: <a href="Node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="Node.html#method-i-classes"><code>#classes</code></a>, <a href="Node.html#method-i-append_class"><code>#append_class</code></a>, <a href="Node.html#method-i-remove_class"><code>#remove_class</code></a></p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul><li>
<p><code>names</code> (String, Array&lt;String&gt;)</p>

<p><a href="../CSS.html"><code>CSS</code></a> class names to be added to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will not be added. Any class names not present will be added. If no “class” attribute exists, one is created.</p>
</li></ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><code>self</code> (<a href="Node.html"><code>Node</code></a>) for ease of chaining method calls.</p>
</dd>
</dl>

<p><strong>Example:</strong> Ensure that the node has <a href="../CSS.html"><code>CSS</code></a> class “section”</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                      <span class="ruby-comment"># =&gt; &lt;div&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">add_class</span>(<span class="ruby-string">"section"</span>) <span class="ruby-comment"># =&gt; &lt;div class="section"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">add_class</span>(<span class="ruby-string">"section"</span>) <span class="ruby-comment"># =&gt; &lt;div class="section"&gt;&lt;/div&gt; # duplicate not added</span>
</pre>

<p><strong>Example:</strong> Ensure that the node has <a href="../CSS.html"><code>CSS</code></a> classes “section” and “header”, via a String argument</p>

<p>Note that the <a href="../CSS.html"><code>CSS</code></a> class “section” is not added because it is already present. Note also that the pre-existing duplicate <a href="../CSS.html"><code>CSS</code></a> class “section” is not removed.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                             <span class="ruby-comment"># =&gt; &lt;div class="section section"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">add_class</span>(<span class="ruby-string">"section header"</span>) <span class="ruby-comment"># =&gt; &lt;div class="section section header"&gt;&lt;/div&gt;</span>
</pre>

<p><strong>Example:</strong> Ensure that the node has <a href="../CSS.html"><code>CSS</code></a> classes “section” and “header”, via an Array argument</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                  <span class="ruby-comment"># =&gt; &lt;div&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">add_class</span>([<span class="ruby-string">"section"</span>, <span class="ruby-string">"header"</span>]) <span class="ruby-comment"># =&gt; &lt;div class="section header"&gt;&lt;/div&gt;</span>
</pre>

          <div class="method-source-code" id="add_class-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 621</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">add_class</span>(<span class="ruby-identifier">names</span>)
  <span class="ruby-identifier">kwattr_add</span>(<span class="ruby-string">"class"</span>, <span class="ruby-identifier">names</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-append_class" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            append_class(names) → self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Add <a href="../HTML4.html"><code>HTML</code></a> <a href="../CSS.html"><code>CSS</code></a> classes to <code>self</code>, regardless of duplication. Compare with <a href="Node.html#method-i-add_class"><code>#add_class</code></a>.</p>

<p>This is a convenience function and is equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_append</span>(<span class="ruby-string">"class"</span>, <span class="ruby-identifier">names</span>)
</pre>

<p>See related: <a href="Node.html#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="Node.html#method-i-classes"><code>#classes</code></a>, <a href="Node.html#method-i-add_class"><code>#add_class</code></a>, <a href="Node.html#method-i-remove_class"><code>#remove_class</code></a></p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul><li>
<p><code>names</code> (String, Array&lt;String&gt;)</p>

<p><a href="../CSS.html"><code>CSS</code></a> class names to be appended to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. All class names passed in will be appended to the “class” attribute even if they are already present in the attribute value. If no “class” attribute exists, one is created.</p>
</li></ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><code>self</code> (<a href="Node.html"><code>Node</code></a>) for ease of chaining method calls.</p>
</dd>
</dl>

<p><strong>Example:</strong> Append “section” to the node’s <a href="../CSS.html"><code>CSS</code></a> “class” attribute</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                         <span class="ruby-comment"># =&gt; &lt;div&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">append_class</span>(<span class="ruby-string">"section"</span>) <span class="ruby-comment"># =&gt; &lt;div class="section"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">append_class</span>(<span class="ruby-string">"section"</span>) <span class="ruby-comment"># =&gt; &lt;div class="section section"&gt;&lt;/div&gt; # duplicate added!</span>
</pre>

<p><strong>Example:</strong> Append “section” and “header” to the noded’s <a href="../CSS.html"><code>CSS</code></a> “class” attribute, via a String argument</p>

<p>Note that the <a href="../CSS.html"><code>CSS</code></a> class “section” is appended even though it is already present</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                <span class="ruby-comment"># =&gt; &lt;div class="section section"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">append_class</span>(<span class="ruby-string">"section header"</span>) <span class="ruby-comment"># =&gt; &lt;div class="section section section header"&gt;&lt;/div&gt;</span>
</pre>

<p><strong>Example:</strong> Append “section” and “header” to the node’s <a href="../CSS.html"><code>CSS</code></a> “class” attribute, via an Array argument</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                     <span class="ruby-comment"># =&gt; &lt;div&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">append_class</span>([<span class="ruby-string">"section"</span>, <span class="ruby-string">"header"</span>]) <span class="ruby-comment"># =&gt; &lt;div class="section header"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">append_class</span>([<span class="ruby-string">"section"</span>, <span class="ruby-string">"header"</span>]) <span class="ruby-comment"># =&gt; &lt;div class="section header section header"&gt;&lt;/div&gt;</span>
</pre>

          <div class="method-source-code" id="append_class-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 665</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">append_class</span>(<span class="ruby-identifier">names</span>)
  <span class="ruby-identifier">kwattr_append</span>(<span class="ruby-string">"class"</span>, <span class="ruby-identifier">names</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-attr" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">attr</span><span class="method-args">(name)</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-5B-5D">[]</a>
        </div>
      </div>

      <div id="method-i-attribute" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            attribute(name) → Nokogiri::XML::Attr
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Attribute (<a href="Attr.html"><code>Nokogiri::XML::Attr</code></a>) belonging to this node with name <code>name</code>.</p>
</dd>
</dl>

<p>⚠ Note that attribute namespaces are ignored and only the simple (non-namespace-prefixed) name is used to find a matching attribute. In case of a simple name collision, only one of the matching attributes will be returned. In this case, you will need to use <a href="Node.html#method-i-attribute_with_ns"><code>#attribute_with_ns</code></a>.</p>

<p><strong>Example:</strong></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-string">"&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;"</span>)
<span class="ruby-identifier">child</span> = <span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>)
<span class="ruby-identifier">child</span>.<span class="ruby-identifier">attribute</span>(<span class="ruby-string">"size"</span>) <span class="ruby-comment"># =&gt; #&lt;Nokogiri::XML::Attr:0x550 name="size" value="large"&gt;</span>
<span class="ruby-identifier">child</span>.<span class="ruby-identifier">attribute</span>(<span class="ruby-string">"class"</span>) <span class="ruby-comment"># =&gt; #&lt;Nokogiri::XML::Attr:0x564 name="class" value="big wide tall"&gt;</span>
</pre>

<p><strong>Example</strong> showing that namespaced attributes will not be returned:</p>

<p>⚠ Note that only one of the two matching attributes is returned.</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attribute</span>(<span class="ruby-string">"size"</span>)
<span class="ruby-comment"># =&gt; #(Attr:0x550 {</span>
<span class="ruby-comment">#      name = "size",</span>
<span class="ruby-comment">#      namespace = #(Namespace:0x564 {</span>
<span class="ruby-comment">#        prefix = "width",</span>
<span class="ruby-comment">#        href = "http://example.com/widths"</span>
<span class="ruby-comment">#        }),</span>
<span class="ruby-comment">#      value = "broad"</span>
<span class="ruby-comment">#      })</span>
</pre>

          <div class="method-source-code" id="attribute-source">
            <pre>static VALUE
rb_xml_node_attribute(VALUE self, VALUE name)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasProp(node, (xmlChar *)StringValueCStr(name));

  if (! prop) { return Qnil; }
  return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-attribute_nodes" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            attribute_nodes() → Array&lt;Nokogiri::XML::Attr&gt;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Attributes (an Array of <a href="Attr.html"><code>Nokogiri::XML::Attr</code></a>) belonging to this node.</p>
</dd>
</dl>

<p>Note that this is the preferred alternative to <a href="Node.html#method-i-attributes"><code>#attributes</code></a> when the simple (non-namespace-prefixed) attribute names may collide.</p>

<p><strong>Example:</strong></p>

<p>Contrast this with the colliding-name example from <a href="Node.html#method-i-attributes"><code>#attributes</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attribute_nodes</span>
<span class="ruby-comment"># =&gt; [#(Attr:0x550 {</span>
<span class="ruby-comment">#       name = "size",</span>
<span class="ruby-comment">#       namespace = #(Namespace:0x564 {</span>
<span class="ruby-comment">#         prefix = "width",</span>
<span class="ruby-comment">#         href = "http://example.com/widths"</span>
<span class="ruby-comment">#         }),</span>
<span class="ruby-comment">#       value = "broad"</span>
<span class="ruby-comment">#       }),</span>
<span class="ruby-comment">#     #(Attr:0x578 {</span>
<span class="ruby-comment">#       name = "size",</span>
<span class="ruby-comment">#       namespace = #(Namespace:0x58c {</span>
<span class="ruby-comment">#         prefix = "height",</span>
<span class="ruby-comment">#         href = "http://example.com/heights"</span>
<span class="ruby-comment">#         }),</span>
<span class="ruby-comment">#       value = "tall"</span>
<span class="ruby-comment">#       })]</span>
</pre>

          <div class="method-source-code" id="attribute_nodes-source">
            <pre>static VALUE
rb_xml_node_attribute_nodes(VALUE rb_node)
{
  xmlNodePtr c_node;

  Data_Get_Struct(rb_node, xmlNode, c_node);

  return noko_xml_node_attrs(c_node);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-attribute_with_ns" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            attribute_with_ns(name, namespace) → Nokogiri::XML::Attr
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Attribute (<a href="Attr.html"><code>Nokogiri::XML::Attr</code></a>) belonging to this node with matching <code>name</code> and <code>namespace</code>.</p>
</dd>
</dl>
<ul>
<li>
<p><code>name</code> (String): the simple (non-namespace-prefixed) name of the attribute</p>
</li>
<li>
<p><code>namespace</code> (String): the URI of the attribute’s namespace</p>
</li>
</ul>

<p>See related: <a href="Node.html#method-i-attribute"><code>#attribute</code></a></p>

<p><strong>Example:</strong></p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attribute_with_ns</span>(<span class="ruby-string">"size"</span>, <span class="ruby-string">"http://example.com/widths"</span>)
<span class="ruby-comment"># =&gt; #(Attr:0x550 {</span>
<span class="ruby-comment">#      name = "size",</span>
<span class="ruby-comment">#      namespace = #(Namespace:0x564 {</span>
<span class="ruby-comment">#        prefix = "width",</span>
<span class="ruby-comment">#        href = "http://example.com/widths"</span>
<span class="ruby-comment">#        }),</span>
<span class="ruby-comment">#      value = "broad"</span>
<span class="ruby-comment">#      })</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attribute_with_ns</span>(<span class="ruby-string">"size"</span>, <span class="ruby-string">"http://example.com/heights"</span>)
<span class="ruby-comment"># =&gt; #(Attr:0x578 {</span>
<span class="ruby-comment">#      name = "size",</span>
<span class="ruby-comment">#      namespace = #(Namespace:0x58c {</span>
<span class="ruby-comment">#        prefix = "height",</span>
<span class="ruby-comment">#        href = "http://example.com/heights"</span>
<span class="ruby-comment">#        }),</span>
<span class="ruby-comment">#      value = "tall"</span>
<span class="ruby-comment">#      })</span>
</pre>

          <div class="method-source-code" id="attribute_with_ns-source">
            <pre>static VALUE
rb_xml_node_attribute_with_ns(VALUE self, VALUE name, VALUE namespace)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasNsProp(node, (xmlChar *)StringValueCStr(name),
                      NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace));

  if (! prop) { return Qnil; }
  return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-attributes" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            attributes() → Hash&lt;String ⇒ Nokogiri::XML::Attr&gt;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Fetch this node’s attributes.</p>

<p>⚠ Because the keys do not include any namespace information for the attribute, in case of a simple name collision, not all attributes will be returned. In this case, you will need to use <a href="Node.html#method-i-attribute_nodes"><code>#attribute_nodes</code></a>.</p>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>Hash containing attributes belonging to <code>self</code>. The hash keys are String attribute names (without the namespace), and the hash values are <a href="Attr.html"><code>Nokogiri::XML::Attr</code></a>.</p>
</dd>
</dl>

<p><strong>Example</strong> with no namespaces:</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-string">"&lt;root&gt;&lt;child size='large' class='big wide tall'/&gt;&lt;/root&gt;"</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attributes</span>
<span class="ruby-comment"># =&gt; {"size"=&gt;#(Attr:0x550 { name = "size", value = "large" }),</span>
<span class="ruby-comment">#     "class"=&gt;#(Attr:0x564 { name = "class", value = "big wide tall" })}</span>
</pre>

<p><strong>Example</strong> with a namespace:</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-string">"&lt;root xmlns:desc='http://example.com/sizes'&gt;&lt;child desc:size='large'/&gt;&lt;/root&gt;"</span>)
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attributes</span>
<span class="ruby-comment"># =&gt; {"size"=&gt;</span>
<span class="ruby-comment">#      #(Attr:0x550 {</span>
<span class="ruby-comment">#        name = "size",</span>
<span class="ruby-comment">#        namespace = #(Namespace:0x564 {</span>
<span class="ruby-comment">#          prefix = "desc",</span>
<span class="ruby-comment">#          href = "http://example.com/sizes"</span>
<span class="ruby-comment">#          }),</span>
<span class="ruby-comment">#        value = "large"</span>
<span class="ruby-comment">#        })}</span>
</pre>

<p><strong>Example</strong> with an attribute name collision:</p>

<p>⚠ Note that only one of the attributes is returned in the Hash.</p>

<pre class="ruby"><span class="ruby-identifier">doc</span> = <span class="ruby-constant">Nokogiri</span><span class="ruby-operator">::</span><span class="ruby-constant">XML</span>(<span class="ruby-identifier">&lt;&lt;~EOF</span>)
<span class="ruby-value">  &lt;root xmlns:width='http://example.com/widths'
        xmlns:height='http://example.com/heights'&gt;
    &lt;child width:size='broad' height:size='tall'/&gt;
  &lt;/root&gt;
</span><span class="ruby-identifier">EOF</span>
<span class="ruby-identifier">doc</span>.<span class="ruby-identifier">at_css</span>(<span class="ruby-string">"child"</span>).<span class="ruby-identifier">attributes</span>
<span class="ruby-comment"># =&gt; {"size"=&gt;</span>
<span class="ruby-comment">#      #(Attr:0x550 {</span>
<span class="ruby-comment">#        name = "size",</span>
<span class="ruby-comment">#        namespace = #(Namespace:0x564 {</span>
<span class="ruby-comment">#          prefix = "height",</span>
<span class="ruby-comment">#          href = "http://example.com/heights"</span>
<span class="ruby-comment">#          }),</span>
<span class="ruby-comment">#        value = "tall"</span>
<span class="ruby-comment">#        })}</span>
</pre>

          <div class="method-source-code" id="attributes-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 515</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attributes</span>
  <span class="ruby-identifier">attribute_nodes</span>.<span class="ruby-identifier">each_with_object</span>({}) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span>, <span class="ruby-identifier">hash</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">node</span>.<span class="ruby-identifier">node_name</span>] = <span class="ruby-identifier">node</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-classes" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            classes() → Array&lt;String&gt;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Fetch <a href="../CSS.html"><code>CSS</code></a> class names of a <a href="Node.html"><code>Node</code></a>.</p>

<p>This is a convenience function and is equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_values</span>(<span class="ruby-string">"class"</span>)
</pre>

<p>See related: <a href="Node.html#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="Node.html#method-i-add_class"><code>#add_class</code></a>, <a href="Node.html#method-i-append_class"><code>#append_class</code></a>, <a href="Node.html#method-i-remove_class"><code>#remove_class</code></a></p>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>The <a href="../CSS.html"><code>CSS</code></a> classes (Array of String) present in the Node’s “class” attribute. If the attribute is empty or non-existent, the return value is an empty array.</p>
</dd>
</dl>

<p><strong>Example</strong></p>

<pre class="ruby"><span class="ruby-identifier">node</span>         <span class="ruby-comment"># =&gt; &lt;div class="section title header"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">classes</span> <span class="ruby-comment"># =&gt; ["section", "title", "header"]</span>
</pre>

          <div class="method-source-code" id="classes-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 575</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">classes</span>
  <span class="ruby-identifier">kwattr_values</span>(<span class="ruby-string">"class"</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">delete</span><span class="method-args">(name)</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-remove_attribute">remove_attribute</a>
        </div>
      </div>

      <div id="method-i-each" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">each</span><span class="method-args">() { |node_name, value| ... }</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Iterate over each attribute name and value pair for this <a href="Node.html"><code>Node</code></a>.</p>

          <div class="method-source-code" id="each-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 541</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">each</span>
  <span class="ruby-identifier">attribute_nodes</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> [<span class="ruby-identifier">node</span>.<span class="ruby-identifier">node_name</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_attribute" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">get_attribute</span><span class="method-args">(name)</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-5B-5D">[]</a>
        </div>
      </div>

      <div id="method-i-has_attribute-3F" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">has_attribute?</span><span class="method-args">(p1)</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-key-3F">key?</a>
        </div>
      </div>

      <div id="method-i-keys" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">keys</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get the attribute names for this <a href="Node.html"><code>Node</code></a>.</p>

          <div class="method-source-code" id="keys-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 535</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">keys</span>
  <span class="ruby-identifier">attribute_nodes</span>.<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:node_name</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-kwattr_add" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            kwattr_add(attribute_name, keywords) → self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Ensure that values are present in a keyword attribute.</p>

<p>Any values in <code>keywords</code> that already exist in the Node’s attribute values are <em>not</em> added. Note that any existing duplicates in the attribute values are not removed. Compare with <a href="Node.html#method-i-kwattr_append"><code>#kwattr_append</code></a>.</p>

<p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../HTML4.html"><code>HTML</code></a> “class” attribute used to contain <a href="../CSS.html"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p>

<p>See also <a href="Node.html#method-i-add_class"><code>#add_class</code></a>, <a href="Node.html#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="Node.html#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="Node.html#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul>
<li>
<p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p>
</li>
<li>
<p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be added to the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. Any values already present will not be added. Any values not present will be added. If the named attribute does not exist, it is created.</p>
</li>
</ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><code>self</code> (<a href="Node.html"><code>Nokogiri::XML::Node</code></a>) for ease of chaining method calls.</p>
</dd>
</dl>

<p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” in its <code>rel</code> attribute.</p>

<p>Note that duplicates are not added.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                               <span class="ruby-comment"># =&gt; &lt;a&gt;&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_add</span>(<span class="ruby-string">"rel"</span>, <span class="ruby-string">"nofollow"</span>) <span class="ruby-comment"># =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_add</span>(<span class="ruby-string">"rel"</span>, <span class="ruby-string">"nofollow"</span>) <span class="ruby-comment"># =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;</span>
</pre>

<p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” and “noreferrer” in its <code>rel</code> attribute, via a String argument.</p>

<pre>Note that "nofollow" is not added because it is already present. Note also that the
pre-existing duplicate "nofollow" is not removed.

 node                                          # =&gt; &lt;a rel="nofollow nofollow"&gt;&lt;/a&gt;
 node.kwattr_add("rel", "nofollow noreferrer") # =&gt; &lt;a rel="nofollow nofollow noreferrer"&gt;&lt;/a&gt;</pre>

<p><strong>Example:</strong> Ensure that a <code>Node</code> has “nofollow” and “noreferrer” in its <code>rel</code> attribute, via an Array argument.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                               <span class="ruby-comment"># =&gt; &lt;a&gt;&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_add</span>(<span class="ruby-string">"rel"</span>, [<span class="ruby-string">"nofollow"</span>, <span class="ruby-string">"noreferrer"</span>]) <span class="ruby-comment"># =&gt; &lt;a rel="nofollow noreferrer"&gt;&lt;/a&gt;</span>
</pre>

<p>Since v1.11.0</p>

          <div class="method-source-code" id="kwattr_add-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 798</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwattr_add</span>(<span class="ruby-identifier">attribute_name</span>, <span class="ruby-identifier">keywords</span>)
  <span class="ruby-identifier">keywords</span> = <span class="ruby-identifier">keywordify</span>(<span class="ruby-identifier">keywords</span>)
  <span class="ruby-identifier">current_kws</span> = <span class="ruby-identifier">kwattr_values</span>(<span class="ruby-identifier">attribute_name</span>)
  <span class="ruby-identifier">new_kws</span> = (<span class="ruby-identifier">current_kws</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">keywords</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">current_kws</span>)).<span class="ruby-identifier">join</span>(<span class="ruby-string">" "</span>)
  <span class="ruby-identifier">set_attribute</span>(<span class="ruby-identifier">attribute_name</span>, <span class="ruby-identifier">new_kws</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-kwattr_append" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            kwattr_append(attribute_name, keywords) → self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Add keywords to a Node’s keyword attribute, regardless of duplication. Compare with <a href="Node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>.</p>

<p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../HTML4.html"><code>HTML</code></a> “class” attribute used to contain <a href="../CSS.html"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p>

<p>See also <a href="Node.html#method-i-append_class"><code>#append_class</code></a>, <a href="Node.html#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="Node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="Node.html#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul>
<li>
<p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p>
</li>
<li>
<p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be added to the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. All values passed in will be appended to the named attribute even if they are already present in the attribute. If the named attribute does not exist, it is created.</p>
</li>
</ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><code>self</code> (<a href="Node.html"><code>Node</code></a>) for ease of chaining method calls.</p>
</dd>
</dl>

<p><strong>Example:</strong> Append “nofollow” to the <code>rel</code> attribute.</p>

<p>Note that duplicates are added.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                  <span class="ruby-comment"># =&gt; &lt;a&gt;&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_append</span>(<span class="ruby-string">"rel"</span>, <span class="ruby-string">"nofollow"</span>) <span class="ruby-comment"># =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_append</span>(<span class="ruby-string">"rel"</span>, <span class="ruby-string">"nofollow"</span>) <span class="ruby-comment"># =&gt; &lt;a rel="nofollow nofollow"&gt;&lt;/a&gt;</span>
</pre>

<p><strong>Example:</strong> Append “nofollow” and “noreferrer” to the <code>rel</code> attribute, via a String argument.</p>

<p>Note that “nofollow” is appended even though it is already present.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                             <span class="ruby-comment"># =&gt; &lt;a rel="nofollow"&gt;&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_append</span>(<span class="ruby-string">"rel"</span>, <span class="ruby-string">"nofollow noreferrer"</span>) <span class="ruby-comment"># =&gt; &lt;a rel="nofollow nofollow noreferrer"&gt;&lt;/a&gt;</span>
</pre>

<p><strong>Example:</strong> Append “nofollow” and “noreferrer” to the <code>rel</code> attribute, via an Array argument.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                                  <span class="ruby-comment"># =&gt; &lt;a&gt;&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_append</span>(<span class="ruby-string">"rel"</span>, [<span class="ruby-string">"nofollow"</span>, <span class="ruby-string">"noreferrer"</span>]) <span class="ruby-comment"># =&gt; &lt;a rel="nofollow noreferrer"&gt;&lt;/a&gt;</span>
</pre>

<p>Since v1.11.0</p>

          <div class="method-source-code" id="kwattr_append-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 851</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwattr_append</span>(<span class="ruby-identifier">attribute_name</span>, <span class="ruby-identifier">keywords</span>)
  <span class="ruby-identifier">keywords</span> = <span class="ruby-identifier">keywordify</span>(<span class="ruby-identifier">keywords</span>)
  <span class="ruby-identifier">current_kws</span> = <span class="ruby-identifier">kwattr_values</span>(<span class="ruby-identifier">attribute_name</span>)
  <span class="ruby-identifier">new_kws</span> = (<span class="ruby-identifier">current_kws</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">keywords</span>).<span class="ruby-identifier">join</span>(<span class="ruby-string">" "</span>)
  <span class="ruby-identifier">set_attribute</span>(<span class="ruby-identifier">attribute_name</span>, <span class="ruby-identifier">new_kws</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-kwattr_remove" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            kwattr_remove(attribute_name, keywords) → self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Remove keywords from a keyword attribute. Any matching keywords that exist in the named attribute are removed, including any multiple entries.</p>

<p>If no keywords remain after this operation, or if <code>keywords</code> is <code>nil</code>, the attribute is deleted from the node.</p>

<p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../HTML4.html"><code>HTML</code></a> “class” attribute used to contain <a href="../CSS.html"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p>

<p>See also <a href="Node.html#method-i-remove_class"><code>#remove_class</code></a>, <a href="Node.html#method-i-kwattr_values"><code>#kwattr_values</code></a>, <a href="Node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="Node.html#method-i-kwattr_append"><code>#kwattr_append</code></a></p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul>
<li>
<p><code>attribute_name</code> (String) The name of the keyword attribute to be modified.</p>
</li>
<li>
<p><code>keywords</code> (String, Array&lt;String&gt;) Keywords to be removed from the attribute named <code>attribute_name</code>. May be a string containing whitespace-delimited values, or an Array of String values. Any keywords present in the named attribute will be removed. If no keywords remain, or if <code>keywords</code> is nil, the attribute is deleted.</p>
</li>
</ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><code>self</code> (<a href="Node.html"><code>Node</code></a>) for ease of chaining method calls.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<p>Note that the <code>rel</code> attribute is deleted when empty.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                    <span class="ruby-comment"># =&gt; &lt;a rel="nofollow noreferrer"&gt;link&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_remove</span>(<span class="ruby-string">"rel"</span>, <span class="ruby-string">"nofollow"</span>)   <span class="ruby-comment"># =&gt; &lt;a rel="noreferrer"&gt;link&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_remove</span>(<span class="ruby-string">"rel"</span>, <span class="ruby-string">"noreferrer"</span>) <span class="ruby-comment"># =&gt; &lt;a&gt;link&lt;/a&gt;</span>
</pre>

<p>Since v1.11.0</p>

          <div class="method-source-code" id="kwattr_remove-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 894</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwattr_remove</span>(<span class="ruby-identifier">attribute_name</span>, <span class="ruby-identifier">keywords</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">keywords</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">remove_attribute</span>(<span class="ruby-identifier">attribute_name</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">keywords</span> = <span class="ruby-identifier">keywordify</span>(<span class="ruby-identifier">keywords</span>)
  <span class="ruby-identifier">current_kws</span> = <span class="ruby-identifier">kwattr_values</span>(<span class="ruby-identifier">attribute_name</span>)
  <span class="ruby-identifier">new_kws</span> = <span class="ruby-identifier">current_kws</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">keywords</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_kws</span>.<span class="ruby-identifier">empty?</span>
    <span class="ruby-identifier">remove_attribute</span>(<span class="ruby-identifier">attribute_name</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">set_attribute</span>(<span class="ruby-identifier">attribute_name</span>, <span class="ruby-identifier">new_kws</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">" "</span>))
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-kwattr_values" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            kwattr_values(attribute_name) → Array&lt;String&gt;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Fetch values from a keyword attribute of a <a href="Node.html"><code>Node</code></a>.</p>

<p>A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the <a href="../HTML4.html"><code>HTML</code></a> “class” attribute used to contain <a href="../CSS.html"><code>CSS</code></a> classes. But other keyword attributes exist, for instance <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel">the “rel” attribute</a>.</p>

<p>See also <a href="Node.html#method-i-classes"><code>#classes</code></a>, <a href="Node.html#method-i-kwattr_add"><code>#kwattr_add</code></a>, <a href="Node.html#method-i-kwattr_append"><code>#kwattr_append</code></a>, <a href="Node.html#method-i-kwattr_remove"><code>#kwattr_remove</code></a></p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul><li>
<p><code>attribute_name</code> (String) The name of the keyword attribute to be inspected.</p>
</li></ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p>(Array&lt;String&gt;) The values present in the Node’s <code>attribute_name</code> attribute. If the attribute is empty or non-existent, the return value is an empty array.</p>
</dd>
</dl>

<p><strong>Example:</strong></p>

<pre class="ruby"><span class="ruby-identifier">node</span>                      <span class="ruby-comment"># =&gt; &lt;a rel="nofollow noopener external"&gt;link&lt;/a&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_values</span>(<span class="ruby-string">"rel"</span>) <span class="ruby-comment"># =&gt; ["nofollow", "noopener", "external"]</span>
</pre>

<p>Since v1.11.0</p>

          <div class="method-source-code" id="kwattr_values-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 744</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kwattr_values</span>(<span class="ruby-identifier">attribute_name</span>)
  <span class="ruby-identifier">keywordify</span>(<span class="ruby-identifier">get_attribute</span>(<span class="ruby-identifier">attribute_name</span>) <span class="ruby-operator">||</span> [])
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-remove_attribute" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">remove_attribute</span><span class="method-args">(name)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Remove the attribute named <code>name</code></p>

          <div class="method-source-code" id="remove_attribute-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 549</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_attribute</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-identifier">attr</span> = <span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">name</span>].<span class="ruby-identifier">remove</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">key?</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-identifier">clear_xpath_context</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">Nokogiri</span>.<span class="ruby-identifier">jruby?</span>
  <span class="ruby-identifier">attr</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Node.html#method-i-delete">delete</a>
        </div>

      </div>

      <div id="method-i-remove_class" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            remove_class(css_classes) → self
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Remove <a href="../HTML4.html"><code>HTML</code></a> <a href="../CSS.html"><code>CSS</code></a> classes from this node. Any <a href="../CSS.html"><code>CSS</code></a> class names in <code>css_classes</code> that exist in this node’s “class” attribute are removed, including any multiple entries.</p>

<p>If no <a href="../CSS.html"><code>CSS</code></a> classes remain after this operation, or if <code>css_classes</code> is <code>nil</code>, the “class” attribute is deleted from the node.</p>

<p>This is a convenience function and is equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">node</span>.<span class="ruby-identifier">kwattr_remove</span>(<span class="ruby-string">"class"</span>, <span class="ruby-identifier">css_classes</span>)
</pre>

<p>Also see <a href="Node.html#method-i-kwattr_remove"><code>#kwattr_remove</code></a>, <a href="Node.html#method-i-classes"><code>#classes</code></a>, <a href="Node.html#method-i-add_class"><code>#add_class</code></a>, <a href="Node.html#method-i-append_class"><code>#append_class</code></a></p>
<dl class="rdoc-list label-list">
<dt>Parameters
</dt>
<dd></dd>
</dl>
<ul><li>
<p><code>css_classes</code> (String, Array&lt;String&gt;)</p>

<p><a href="../CSS.html"><code>CSS</code></a> class names to be removed from the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will be removed. If no <a href="../CSS.html"><code>CSS</code></a> classes remain, the “class” attribute is deleted.</p>
</li></ul>
<dl class="rdoc-list label-list">
<dt>Returns
</dt>
<dd>
<p><code>self</code> (<a href="Node.html"><code>Nokogiri::XML::Node</code></a>) for ease of chaining method calls.</p>
</dd>
</dl>

<p><strong>Example</strong>: Deleting a <a href="../CSS.html"><code>CSS</code></a> class</p>

<p>Note that all instances of the class “section” are removed from the “class” attribute.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                         <span class="ruby-comment"># =&gt; &lt;div class="section header section"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">remove_class</span>(<span class="ruby-string">"section"</span>) <span class="ruby-comment"># =&gt; &lt;div class="header"&gt;&lt;/div&gt;</span>
</pre>

<p><strong>Example</strong>: Deleting the only remaining <a href="../CSS.html"><code>CSS</code></a> class</p>

<p>Note that the attribute is removed once there are no remaining classes.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                         <span class="ruby-comment"># =&gt; &lt;div class="section"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">remove_class</span>(<span class="ruby-string">"section"</span>) <span class="ruby-comment"># =&gt; &lt;div&gt;&lt;/div&gt;</span>
</pre>

<p><strong>Example</strong>: Deleting multiple <a href="../CSS.html"><code>CSS</code></a> classes</p>

<p>Note that the “class” attribute is deleted once it’s empty.</p>

<pre class="ruby"><span class="ruby-identifier">node</span>                                    <span class="ruby-comment"># =&gt; &lt;div class="section header float"&gt;&lt;/div&gt;</span>
<span class="ruby-identifier">node</span>.<span class="ruby-identifier">remove_class</span>([<span class="ruby-string">"section"</span>, <span class="ruby-string">"float"</span>]) <span class="ruby-comment"># =&gt; &lt;div class="header"&gt;&lt;/div&gt;</span>
</pre>

          <div class="method-source-code" id="remove_class-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 715</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">remove_class</span>(<span class="ruby-identifier">names</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">kwattr_remove</span>(<span class="ruby-string">"class"</span>, <span class="ruby-identifier">names</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_attribute" class="method-detail method-alias">
        <div class="method-heading">
          <span class="method-name">set_attribute</span><span class="method-args">(name, value)</span>
        </div>

        <div class="method-description">
          

        </div>


        <div class="aliases">
          Alias for: <a href="Node.html#method-i-5B-5D-3D">[]=</a>
        </div>
      </div>

      <div id="method-i-value-3F" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">value?</span><span class="method-args">(value)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Does this Node’s attributes include &lt;value&gt;</p>

          <div class="method-source-code" id="value-3F-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 529</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">value?</span>(<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">values</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">value</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-values" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">values</span><span class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get the attribute values for this <a href="Node.html"><code>Node</code></a>.</p>

          <div class="method-source-code" id="values-source">
            <pre><span class="ruby-comment"># File lib/nokogiri/xml/node.rb, line 523</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">values</span>
  <span class="ruby-identifier">attribute_nodes</span>.<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:value</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  </p>
<p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  </p>
<p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</p></footer>

</body>
</html>
